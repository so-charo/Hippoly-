<!DOCTYPE html>
<html data-theme="light" lang="ja">
 <head>
  <meta charset="utf-8">
  <title>Hippoly!</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
 <link rel="icon" type="image/png" href="./favfavicon-192.png">


  <!-- iOS & PWA ç”¨ã‚¢ã‚¤ã‚³ãƒ³ã®ã¿ -->
  <link rel="apple-touch-icon" href="./favicon-192.png">
  <link rel="manifest" href="./manifest.json">

  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">

  <link rel="stylesheet" href="./style.css">
  <style>
   :root {
      
      --page-bg:#f7fafc;
      --text:#111827;
      --panel-bg:#ffffff;
      --panel-shadow:0 10px 30px rgba(0,0,0,.06);
      --accent:#2563eb;
      --soft:#e5e7eb;

      
      --btn-bg:#ffffff;
      --btn-border:#e5e7eb;
      --btn-active:#dbeafe;
      --btn-hover-shadow:0 1px 3px rgba(0,0,0,.06);
      --btn-focus:#93c5fd;

      
      --grid-cm:37.7952755906; 
      --grid-stroke:#bfdbfe;   
      --grid-pt:1.0;           

      
      --note-yellow:#fffbe6;
      --note-blue:#e6f3ff;
      --note-pink:#ffeaf1;

      
      --badge-bg:#eef2ff;
      --badge-border:#c7d2fe;
      --badge-text:#1e3a8a;
      --hint:#6b7280;

      --fs-base: 11pt;          
      --aside-width:320px;			 
  		--asideB-width: 220px;    
  		--asideB-cur: var(--asideB-width); 
  		--asideR-cur: var(--aside-width); 
	   	--main-pad-top: 0px;  /* â† ã“ã“ã‚’ 0ï½8px ã§èª¿æ•´ */
	   	--board-pad: 0px; /* ã‚‚ã£ã¨ãƒ”ã‚¿ä»˜ã‘ã—ãŸã‘ã‚Œã° 0 ã« */
	    --shot-size: 70px;   /* â† ã“ã“ã‚’ 28px/32px/40px ã¨ã‹ã«å¤‰ãˆã‚Œã°ã‚µã‚¤ã‚ºå³åæ˜  */
  		--shot-font: 50px;   /* â† çµµæ–‡å­—ã®å¤§ãã•ã€‚ã‚µã‚¤ã‚ºä¸Šã’ãŸã‚‰ 20ã€œ24px ã« */
    }
		
		
		
	main{
	  display:grid;
	  gap:12px;
	  padding: var(--main-pad-top) 12px 12px;
	  overflow:hidden;
	  grid-template-columns: var(--asideB-cur) minmax(0,1fr) var(--asideR-cur);
	  transition: grid-template-columns .15s ease;
	}
  
	body.asideB-collapsed { --asideB-cur: 0px; }
	body.aside-collapsed  { --asideR-cur: 0px; }
	body.swap-sidebars main{
  	grid-template-columns: var(--asideR-cur) minmax(0,1fr) var(--asideB-cur);
	}
    
    
		.asideB     { order: 0; }
		.board-wrap { order: 1; }
		aside       { order: 2; }

		
		body.swap-sidebars .asideB { order: 2; }
		body.swap-sidebars aside   { order: 0; }
    body.swap-sidebars .board-wrap{ order:1; } 

		

	
	.asideB{
  	order:0; background:var(--panel-bg); color:var(--text);
  	border-radius:14px; padding:12px; box-shadow: var(--panel-shadow);
  	overflow:visible;                 
  	position:relative;
  	transition: width .15s ease, opacity .15s ease;
	}

	
	body.asideB-collapsed .asideB {
  	width: 0;
  	padding: 0;
  	border: none;
  	opacity: 1;
  	pointer-events: none;
	}
	body.asideB-collapsed .asideB > .asideB-tab {
  	pointer-events: auto; 
	}
  
	
	body.asideB-collapsed .asideB > *:not(.asideB-tab){ display:none; }

	
	.asideB-tab{
  	position:absolute; right:-26px; top:12px; width:26px; height:44px;
  	display:flex; align-items:center; justify-content:center;
  	background:var(--btn-bg); border:1px solid var(--btn-border);
  	border-radius:0 8px 8px 0;
  	cursor:pointer; box-shadow:var(--btn-hover-shadow);
  	z-index:9999; touch-action:manipulation;
	}
  
	body.aside-collapsed .asideB > .asideB-tab{
  	pointer-events:auto;
	}

	

	
	.aside-tab { left:-26px;  border-radius:8px 0 0 8px; }
	
	body.swap-sidebars .aside-tab{
  	left:auto; right:-26px;
  	border-radius:0 8px 8px 0;
	}

	
	body.swap-sidebars .asideB-tab{
  	left:-26px; right:auto;
  	border-radius:8px 0 0 8px;
	}

	
	#thumbList {
  	display: flex;
  	flex-direction: column;
  	gap: 8px;

  	
  	height: calc(100% - 150px);

  	overflow: auto;
  	border-top: 1px dashed var(--soft);
  	padding-top: 8px;
  	margin-top: 8px;
  	-webkit-overflow-scrolling: touch;
	}
	
		
		.thumb{
  		position:relative;
  		display:flex;                 
  		align-items:stretch;           
  		gap:6px;                      
  		border:1px solid var(--btn-border);
  		border-radius:8px;
  		background:#fff;
  		overflow:hidden;
		}

		
		.thumb .grab{
  		flex:0 0 22px;
  		display:flex; align-items:center; justify-content:center;
  		margin-left:6px; margin-right:2px;
  		user-select:none; -webkit-user-select:none;
  		touch-action:none;             
  		cursor:grab;
  		color:#64748b;
		}
		.thumb.dragging .grab{ cursor:grabbing; }

		
		.thumb img{
  		flex:1 1 auto;                
  		display:block;
  		min-width:0;
  		height:100px;                 
  		object-fit:cover;
		}

		
		#thumbList.dragging .thumb.dragging{
  		opacity:.6;
  		transform:scale(0.98);
			transition: transform .05s ease;
		}
		.thumb .cap{
  		position:absolute; left:6px; top:6px; background:rgba(0,0,0,.5); color:#fff; font-size:12px;
  		padding:2px 6px; border-radius:6px;
		}
		.thumb.dragging{ opacity:.6; }

		
		#lightbox{
  		position:fixed; inset:0; display:none; background:rgba(0,0,0,.8); z-index:99999;
  		align-items:center; justify-content:center;
		}
		#lightbox.show{ display:flex; }
		#lightbox img{ max-width:96vw; max-height:92vh; border-radius:12px; }
		.lb-nav{
  		position:absolute; top:50%; transform:translateY(-50%);
  		width:48px; height:48px; display:flex; align-items:center; justify-content:center;
  		background:rgba(255,255,255,.15); border-radius:50%; color:#fff; font-size:28px; user-select:none;
		}
		.lb-prev{ left:16px; } .lb-next{ right:16px; }
		.lb-close{ position:absolute; right:16px; top:16px; background:#fff; border-radius:8px; padding:6px 10px; }

    
    [data-theme="dark"] {
      --page-bg:#0f172a;
      --text:#e5e7eb;
      --panel-bg:#111827;
      --panel-shadow:0 10px 30px rgba(0,0,0,.35);

      --btn-bg:#1f2937;
      --btn-border:#334155;
      --btn-active:#1d4ed8;
      --btn-hover-shadow:0 1px 3px rgba(255,255,255,.06);
      --btn-focus:#60a5fa;

      --grid-stroke:#334155;
      --grid-pt:1.0;

      --note-yellow:#5b5b3a;
      --note-blue:#334e68;
      --note-pink:#6e3948;

      --badge-bg:#1f2937;
      --badge-border:#374151;
      --badge-text:#dbeafe;
      --hint:#94a3b8;
    }/* header ã®åŸºæœ¬ã¯ sticky å´ã§å®šç¾©ã€‚ã“ã“ã§ã¯â€œä¸­å¤®å¯„ã›â€ã¯ã‚„ã‚‰ãªã„ */
header{
  position: sticky; top: 0; z-index: 10;
  background: var(--panel-bg); color: var(--text);
  padding: 10px 12px; box-shadow: 0 2px 10px rgba(0,0,0,.06);
}

/* 3ã‚«ãƒ©ãƒ ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼šå·¦=title, ä¸­å¤®=header-center, å³=header-actions */
header .row{
  display:flex; align-items:center; gap:10px; justify-content:space-between; flex-wrap:wrap;
}
header .title{
  flex:0 0 auto; font-weight:700; font-size:var(--fs-base);
}

/* ä¸­å¤®ã€‚flex:1 ã§çœŸã‚“ä¸­ã‚’å–ã‚‹ã€‚min-width:0 ã§ã¯ã¿å‡ºã—é˜²æ­¢ */
.header-center{
  flex: 1 1 auto;
  display:flex; align-items:center; justify-content:center;
  gap:8px; flex-wrap:wrap; min-width:0;
}

/* å³ç«¯ã®ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚³ãƒ³ãƒ†ãƒŠ */
.header-actions.right{
  margin-left:auto; display:flex; align-items:center; gap:.5rem; position:relative;
}

/* å³ç«¯ã®ã‚¿ãƒ–ã¨ãƒ¡ãƒ‹ãƒ¥ãƒ¼ */
#headerTab{
  cursor:pointer; user-select:none; padding:.25rem .45rem;
  border:1px solid var(--btn-border,#e5e7eb); border-radius:8px;
}
.header-menu{
  position:absolute; right:0; top:calc(100% + 6px);
  display:none; z-index:1000; min-width:140px;
  background:var(--panel-bg,#fff);
  border:1px solid var(--btn-border,#e5e7eb);
  box-shadow:0 6px 24px rgba(0,0,0,.12);
  border-radius:10px; padding:6px;
}
.header-menu.open{ display:block; }
.header-menu button{ width:100%; text-align:left; font-size:12px; padding:.4rem .6rem; }

/* ---- ä»¥ä¸‹ã¯ä¸€èˆ¬ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆå…ƒã®é‡è¤‡ã‚’çµ±åˆï¼‰ ---- */
*{
  -webkit-user-select:none; user-select:none;
  -webkit-touch-callout:none; -webkit-tap-highlight-color:transparent;
}
.note, .note *{
  -webkit-user-select:text !important; user-select:text !important;
  -webkit-touch-callout:default !important;
}

html, body{ height:100%; overflow:hidden; }
body{
  margin:0;
  font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN",Meiryo,sans-serif;
  font-size:var(--fs-base);
  background:var(--page-bg); color:var(--text);
  display:grid; grid-template-rows:auto 1fr;
  overscroll-behavior:none;
}

select, input[type="color"], button, label.toggle{
  border:1px solid var(--btn-border); background:var(--btn-bg); color:var(--text);
  border-radius:10px; padding:6px 8px; font-size:var(--fs-base);
  transition: box-shadow .12s ease, background .12s ease, transform .04s ease;
}
button{ cursor:pointer; }
button:hover{ box-shadow: var(--btn-hover-shadow); }
button:active{ transform: translateY(0.5px); }
button:focus-visible{ outline:2px solid var(--btn-focus); outline-offset:2px; }
button:disabled{ opacity:.5; cursor:not-allowed; }
.active{ background:var(--btn-active)!important; color:#fff; }
	  
    aside{
      order:2; background:var(--panel-bg); color:var(--text); border-radius:14px;
      padding:12px; box-shadow: var(--panel-shadow);
      overflow: visible;     
      position:relative;
      transition: width .15s ease, opacity .15s ease;
    }
    body.aside-collapsed aside:not(.asideB){
  		width:0; padding:0; border:none; opacity:1;
  		pointer-events:none;
		}
    body.aside-collapsed aside:not(.asideB) > *:not(.aside-tab){
  		display:none;
		}
    .aside-tab {
      position: absolute;
      left: -26px;
      top: 12px;
      width: 26px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--btn-bg);
      border: 1px solid var(--btn-border);
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      box-shadow: var(--btn-hover-shadow);
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
      z-index: 9999;
    }
    body.aside-collapsed .aside-tab{ pointer-events:auto; }

    .board-wrap{
	  order:1; background:var(--panel-bg); color:var(--text);
	  border-radius:14px; padding: var(--board-pad); box-shadow: var(--panel-shadow);
	  position:relative; min-height:420px; overflow:hidden;
	}

    .panel-title{font-size:var(--fs-base); color:var(--hint); margin:2px 0 8px;}
    .group{border-top:1px dashed var(--soft); padding-top:8px; margin-top:8px;}

    .board{width:100%; height:100%; border-radius:12px; display:block; background:#0b0b0b08; touch-action:none;}
		
		.asideB, .asideB *{ font-size: var(--fs-base); }

		
		.thumb .del{
  		position:absolute; right:6px; top:6px;
  		border:1px solid var(--btn-border);
  		background:rgba(255,255,255,0.95);
  		color:#b91c1c; border-radius:6px;
  		padding:2px 6px; font-size:var(--fs-base);
  		cursor:pointer;
		}

		
		.asideB .save-all-wrap{
  		position:absolute; left:12px; right:12px; bottom:36px;
		}
		.asideB .save-all-wrap button{ width:100%; }

    
    canvas.draw, canvas.cursor-layer{
      position:absolute; inset:0; width:100%; height:100%; pointer-events:none; touch-action:none;
    }
    canvas.cursor-layer{ z-index:6; }

    
    #gridLayer line { pointer-events:none; }

    .shape{fill-opacity:.35; stroke-width:2;}
    .selected{filter:drop-shadow(0 0 0.6px rgba(0,0,0,.25));}
    .handle{fill:#fff; stroke:var(--accent); stroke-width:2; cursor:pointer;}
    .bbox-handle{fill:#fff; stroke:#64748b; stroke-width:2; cursor:nwse-resize;}

    
    .rot-stem{ stroke:#94a3b8; stroke-width:2; }
    .rot-handle{
      fill:var(--btn-bg);
      stroke:#64748b;
      stroke-width:2;
      cursor:grab;
    }
    .rot-handle:active{ cursor:grabbing; }

    .badgebar{display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin-top:8px;}
    .badge{ background:var(--badge-bg); color:var(--badge-text);
  		border:1px solid var(--badge-border); border-radius:10px; padding:6px 10px; font-size:var(--fs-base);
		}
		.hint{color:var(--hint); font-size:var(--fs-base); display:none;}

    
    .note-wrap{ position:relative; width:100%; height:100%; overflow:visible; }
    .note{
      width:100%; height:100%;
      padding:6px 8px 10px 8px;
      border-radius:8px; border:1px solid var(--btn-border);
      background:var(--note-yellow);
      box-shadow:0 2px 6px rgba(0,0,0,.08);
      outline:none; line-height:1.4; overflow:auto; color:var(--text);
    }
    .note-yellow{ background:var(--note-yellow); }
    .note-blue  { background:var(--note-blue); }
    .note-pink  { background:var(--note-pink); }

    .note-close{
      position:absolute; right:4px; top:4px;
      border:none; background:rgba(255,255,255,0.85);
      border:1px solid var(--btn-border); border-radius:6px; padding:2px 6px; cursor:pointer; font-size:12px; color:#111;
      touch-action:manipulation;
    }
    [data-theme="dark"] .note-close{ background:rgba(17,24,39,0.9); color:#e5e7eb; }

    .note-resize{
      position:absolute; right:-6px; bottom:-6px; width:18px; height:18px; background:#fff;
      border:1px solid #94a3b8; border-radius:3px; cursor:nwse-resize; box-shadow:0 1px 2px rgba(0,0,0,.1);
    }
    [data-theme="dark"] .note-resize{ background:#1f2937; border-color:#475569; }

    
    #notePanel{ display:none; gap:8px; align-items:center; padding:4px 6px; border:1px solid var(--btn-border); border-radius:10px; }
    
    header .row{
	  min-height: 44px;      /* 56px â†’ 44px ã«å¾®èª¿æ•´ */
	  align-items: center;
	}

    
    #notePanel{
      height: 36px;            
      box-sizing: border-box;
      display: none;           
      align-items: center;     
      gap: 8px;                
    }
    
    .toolbar button { display:inline-flex; align-items:center; gap:6px; touch-action:manipulation; }
    .toolbar button .icon { font-size:16px; line-height:1; }
	  /* ä¸¸ã„ã‚¢ã‚¤ã‚³ãƒ³ãƒœã‚¿ãƒ³ */
	button.icon-round{
	  width: var(--shot-size);
	  height: var(--shot-size);
	  min-width: var(--shot-size);  /* ä¸€éƒ¨ãƒ–ãƒ©ã‚¦ã‚¶ã®æ¨ªã¤ã¶ã‚Œå¯¾ç­– */
	  padding: 0;
	  border-radius: 9999px;
	  display: inline-flex;
	  align-items: center;
	  justify-content: center;
	  font-size: var(--shot-font);
	  line-height: 1;
	}
    
    #toolbar button[data-add] {
      min-width: 120px;   
      height: 44px;       
      justify-content: center;
      text-align: center;
      font-size: 15px;
      border-radius: 10px;
      box-shadow: var(--btn-hover-shadow);
    }
    
    @media (pointer:coarse) {
      .handle { r: 14 !important; }
      .bbox-handle { width: 24px !important; height: 24px !important; }
      button, select, input[type="color"] { padding:12px 14px; }
    }
    
    .toolbar{
      display:grid;
      gap:8px;
      grid-auto-rows: min-content; 
    }
    .draw-row, .erase-row{
  		display:flex; gap:6px; align-items:center; flex-wrap:wrap; margin-top:6px;
		}
    
    header .row {
      align-items: center;
      min-height: 48px;
    }

    
    #vertexEdit, #lockSize, #color {
      display: inline-block;
      vertical-align: middle;
      margin-right: 6px;
    }

    
    main {
      overflow: hidden;
    }
    
		#penColor option[hidden]{
  	display: none !important;
		}
    
    .draw-row select#penThickness {
  		width: 60px;
  		margin-left: 6px;
		}
		.line-check {
  		margin-left: 8px;
  		font-size: 10pt;
		}
		.line-check input {
  		vertical-align: middle;
  		margin-right: 3px;
		}
    
		.save-load.right {
  		display: flex;
  		justify-content: flex-end; 
  		align-items: center;
  		gap: 6px;
  		margin-left: auto; 
		}

		.save-load.small button,
		.save-load.small label {
  		font-size: 10pt;     
  		padding: 3px 6px;
  		border-radius: 6px;
  		background: var(--btn-bg);
  		border: 1px solid var(--btn-border);
  		box-shadow: var(--btn-hover-shadow);
  		cursor: pointer;
  		transition: background 0.15s;
		}

		.save-load.small button:hover,
		.save-load.small label:hover {
  		background: var(--btn-active);
		}
  
	header .row button,
	header .row label.toggle {
  	font-size: 11pt;
  	padding: 6px 10px;            
  	margin: 0 2px;                
  	border-radius: 8px;
  	background: var(--btn-bg);
  	border: 1px solid var(--btn-border);
  	box-shadow: var(--btn-hover-shadow);
  	cursor: pointer;
  	touch-action: manipulation;   
  	transition: background 0.15s;
	}

	header .row button:hover,
	header .row label.toggle:hover {
  	background: var(--btn-active);
	}

	header .row button:active,
	header .row label.toggle:active {
  	transform: scale(0.97);       
	}
  
/* header tools compact */
.header-tools{ margin-left:auto; display:flex; align-items:center; gap:.5rem; }
.header-tools button{ font-size:11px; padding:.25rem .5rem; }
.header-tools .header-tab{ cursor:pointer; user-select:none; padding:.25rem .4rem; border:1px solid var(--btn-border); border-radius:6px; }
body.header-tools-collapsed .header-tools .tools-inner{ display:none; }


/* ========== grid visibility hardening ========== */
html, body { height: 100%; }
main { min-height: calc(100vh - 48px); }
.board-wrap { height: 100%; min-height: 200px; }
#board { display: block; width: 100%; height: 100%; }
canvas#drawCanvas, canvas#cursorCanvas { display:block; width:100%; height:100%; }


/* ==== header/viewport sizing guards ==== */
:root{ --header-h: 44px; }
body{ margin:0; }
header{ box-sizing:border-box; }
main{ box-sizing:border-box; }
.board-wrap{ box-sizing:border-box; }
#board{ display:block; width:100%; height:100%; }
canvas#drawCanvas, canvas#cursorCanvas{ display:block; width:100%; height:100%; }
/* fixed ãƒ˜ãƒƒãƒ€ã®æ™‚ã ã‘ç‰¹åˆ¥æ‰±ã„ã€‚sticky ã¯è‡ªç„¶ã«ç©ã¾ã‚Œã‚‹ã®ã§ä½™ç™½ã¯è¶³ã•ãªã„ */
body.header-fixed main{ padding-top: 0; }
body.header-fixed .board-wrap{ height: auto; }
/* é«˜ã•ç¢ºä¿ã¯ JS ã® ensureLayout ã§ã‚„ã‚‹ã€‚ã“ã“ã§ã¯ä½•ã‚‚è¶³ã•ãªã„ */

/* === header tab menu === */
.header-actions.right{ position:relative; margin-left:auto; display:flex; align-items:center; gap:.5rem; }
#headerTab{ cursor:pointer; user-select:none; padding:.25rem .45rem; border:1px solid var(--btn-border,#e5e7eb); border-radius:8px; }
.header-menu{
  position:absolute; right:0; top:calc(100% + 6px);
  display:none; z-index:1000;
  background:var(--panel-bg,#fff);
  border:1px solid var(--btn-border,#e5e7eb);
  box-shadow:0 6px 24px rgba(0,0,0,.12);
  border-radius:10px; padding:6px; min-width:140px;
}
.header-menu.open{ display:block; }
.header-menu button{ width:100%; text-align:left; font-size:12px; padding:.4rem .6rem; }

/* ãµã›ã‚“è¡Œã‚’ãƒ•ãƒ¬ãƒƒã‚¯ã‚¹åŒ–ã—ã¦ğŸ“·ã‚’å³ç«¯ã¸ */
.toolbar > div:first-child{
  display: flex;
  align-items: center;
  gap: 6px;
  flex-wrap: wrap;           /* å¹…ãŒç‹­ã„æ™‚ã¯æŠ˜ã‚Šè¿”ã™ */
}

/* ğŸ“· ã‚’å³ç«¯ã«æŠ¼ã—ã‚„ã‚‹ */
#shot.icon-round{ margin-left: auto; }

/* ä¸‹ã«ä¸¦ã¶ã€Œæ‰‹æ›¸ãã€ã€Œå›³å½¢ã€ãªã©ã® .group ã¯æ”¹è¡Œã—ã¦å…¨å¹…ã« */
.toolbar > div:first-child > .group{
  flex-basis: 100%;
}

/* ---- ãƒšãƒ³å¤ªã• & æ¶ˆã—ã‚´ãƒ ã‚µã‚¤ã‚ºã®ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ã‚’å®Œå…¨éè¡¨ç¤º ---- */
#penThickness,#eraserSize {display: none !important;}

.inline-controls{display:flex;align-items:center;gap:8px;flex-wrap:nowrap;white-space:nowrap}
.inline-controls .toggle,.inline-controls .color-pick{display:inline-flex;align-items:center;gap:4px}
.inline-controls input[type="checkbox"]{margin:0}
.vertex-handle{display:none}
.show-vertices .vertex-handle{display:block}
	  
</style>
 </head>
 <body>
  <header>
	  <div class="row">
	    <div class="title">ğŸ¦›Hippoly!</div>
	
	    <div class="header-center">
	      <label title="æ–¹çœ¼ã®ã‚µã‚¤ã‚ºã‚’åˆ‡ã‚Šæ›¿ãˆ">
	        æ–¹çœ¼ï¼š
	        <select id="gridSize" title="æ–¹çœ¼">
	          <option value="1">ç´°</option>
	          <option value="2.5" selected>åºƒ</option>
	        </select>
	      </label>
	
	      <button id="undo"  title="æˆ»ã‚‹ï¼ˆUndoï¼‰">â†¶ ã‚‚ã©ã‚‹</button>
	      <button id="redo"  title="é€²ã‚€ï¼ˆRedoï¼‰">â†· ã™ã™ã‚€</button>
	      <button id="reset" title="ãƒªã‚»ãƒƒãƒˆï¼ˆç”»é¢ã‚’å†èª­ã¿è¾¼ã¿ï¼‰">âŸ² ãƒªã‚»ãƒƒãƒˆ</button>
			
	      <div id="notePanel" title="ä»˜ç®‹ã®è¦‹ãŸç›®ã‚’å¤‰æ›´">
	        <select id="noteHdrColor" title="ä»˜ç®‹ã®è‰²">
	          <option value="yellow">é»„è‰²</option>
	          <option value="blue">æ°´è‰²</option>
	          <option value="pink">ãƒ”ãƒ³ã‚¯</option>
	        </select>
	        <select id="noteHdrSize" title="ä»˜ç®‹ã®æ–‡å­—ã‚µã‚¤ã‚º">
	          <option value="s">10pt</option>
	          <option value="m" selected>13pt</option>
	          <option value="l">18pt</option>
	        </select>
	      </div>
	    </div>
	    <div class="header-actions right">
	      <div class="save-load small right" style="display:none">
	        <button id="export" title="ä¿å­˜ï¼ˆJSONã¨ã—ã¦ä¿å­˜ï¼‰">ğŸ’¾ ä¿å­˜</button>
	        <label class="toggle" title="èª­ã¿è¾¼ã¿ï¼ˆä¿å­˜ã—ãŸJSONã‚’é¸æŠï¼‰">
	          ğŸ“‚ èª­ã¿è¾¼ã¿
	          <input id="import" type="file" accept="application/json" style="display:none" />
	        </label>
	      </div>
			<button id="swapSidebars" title="å·¦å³ã®ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‚’å…¥ã‚Œæ›¿ãˆ">â†”ï¸</button>
  			<button id="themeToggle"  title="ãƒ†ãƒ¼ãƒåˆ‡æ›¿ï¼ˆãƒ©ã‚¤ãƒˆ/ãƒ€ãƒ¼ã‚¯ï¼‰">ğŸŒ™</button>
	      <div id="headerTab" class="header-tab" title="ãƒ¡ãƒ‹ãƒ¥ãƒ¼">â—€</div>
	      <div id="headerMenu" class="header-menu">
	        <button type="button" data-act="save">ğŸ’¾ ä¿å­˜</button>
	        <button type="button" data-act="load">ğŸ“‚ èª­ã¿è¾¼ã¿</button>
	      </div>
	    </div>
	  </div>
	</header>

  <main>
   <aside class="asideB">
    <div class="asideB-tab" id="asideBTab" title="é–‹é–‰">
     â–¼
    </div>
    <div class="panel-title">
     ã‚¹ã‚¯ã‚·ãƒ§
    </div>
    <div aria-label="snapshots" id="thumbList">
    </div>
    <div class="save-all-wrap">
     <button id="saveAll" title="ä¸¦ã‚“ã ç”»åƒã‚’ã¾ã¨ã‚ã¦ä¿å­˜">
      ğŸ’¾å…¨ã¦ã®ç”»åƒã‚’ä¿å­˜
     </button>
    </div>
   </aside>
   <div class="board-wrap">
    <svg aria-label="draw-board" class="board" id="board">
    </svg>
    <canvas class="draw" id="drawCanvas">
    </canvas>
    <canvas class="cursor-layer" id="cursorCanvas">
    </canvas>
    <div class="badgebar">
     <span class="badge">
      é¸æŠ:
      <strong id="selType">
       â€”
      </strong>
     </span>
     <span class="badge">
      <span id="wLabel">
       å¹…
      </span>
      :
      <strong id="w">
       â€”
      </strong>
      <span id="u1">
       cm
      </span>
     </span>
     <span class="badge">
      <span id="hLabel">
       é«˜ã•
      </span>
      :
      <strong id="h">
       â€”
      </strong>
      <span id="u2">
       cm
      </span>
     </span>
     <span class="badge">
      é ‚ç‚¹:
      <strong id="vh">
       â€”
      </strong>
     </span>
    </div>
   </div>
   <aside>
    <div class="aside-tab" id="asideTab" title="é–‹é–‰">
     â–¶
    </div>
    <div class="panel-title">
     ãƒ„ãƒ¼ãƒ«
    </div>
    <div class="toolbar" id="toolbar">
     <div>
      <button class="active" data-tool="edit" title="é¸æŠãƒ»ç§»å‹•ãƒ»ãƒªã‚µã‚¤ã‚º">
       <span class="icon">
        ğŸš€
       </span>
       ç§»å‹•
      </button>
      <button data-tool="text" title="ä»˜ç®‹ã‚’1æšé…ç½®">
       <span class="icon">
        ğŸ“
       </span>
       ãµã›ã‚“
      </button>
	ã€€<button id="shot" class="icon-round" title="ä»Šè¦‹ãˆã¦ã‚‹ç¯„å›²ã‚’ç”»åƒåŒ–">ğŸ“·</button>
      <div class="group">
       <div class="panel-title">
        æ‰‹æ›¸ã
       </div>
       <div class="draw-row">
        <button data-tool="draw" title="ãƒšãƒ³">
         <span class="icon">
          ğŸ–Šï¸
         </span>
         ãƒšãƒ³
        </button>
        <select id="penColor" title="è‰²å¤‰ãˆ">
        </select>
        <select id="penThickness" title="å¤ªã•ã‚’é¸æŠ">
         <option value="1.5">
          ç´°
         </option>
         <option value="3.5">
          å¤ª
         </option>
        </select>
        <label class="line-check">
         <input id="penStraight" type="checkbox"/>
         ç›´ç·šã‚’å¼•ã
        </label>
       </div>
       <div class="erase-row">
        <button data-tool="erase" title="æ¶ˆã—ã‚´ãƒ ">
         <span class="icon">
          ğŸ—‘
         </span>
         æ¶ˆã™
        </button>
        <select id="eraserMode" title="æ¶ˆã—ã‚´ãƒ ã®ç¨®é¡">
         <option selected="" value="pixel">
          ãƒ”ã‚¯ã‚»ãƒ«
         </option>
         <option value="object">
          ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
         </option>
         <option value="clear">
          å…¨æ¶ˆã—
         </option>
        </select>
        <select id="eraserSize" title="æ¶ˆã—ã‚´ãƒ ã®ã‚µã‚¤ã‚ºé¸æŠ">
         <option value="8">
          å°
         </option>
         <option selected="" value="14">
          ä¸­
         </option>
         <option value="24">
          å¤§
         </option>
        </select>
       </div>
      </div>
      <div class="group">
       <div class="panel-title">
        å›³å½¢
       </div>
       <button data-add="rect" title="é•·æ–¹å½¢">
        â–­ é•·æ–¹å½¢
       </button>
       <button data-add="para" title="å¹³è¡Œå››è¾ºå½¢">
        â–± å¹³è¡Œå››è¾ºå½¢
       </button>
       <button data-add="tri" title="ä¸‰è§’å½¢">
        â–³ ä¸‰è§’å½¢
       </button>
       <button data-add="trap" title="å°å½¢4ãƒ‘ã‚¿ãƒ¼ãƒ³">
        âƒ å°å½¢
       </button>
       <button data-add="rh" title="ã²ã—å½¢">
        â—‡ ã²ã—å½¢
       </button>
       <button id="deleteShape" title="å›³å½¢å‰Šé™¤">
        âœ– å‰Šé™¤
       </button>
      </div>
      <div class="group">
       <div class="panel-title">
        å›³å½¢ç·¨é›†
       </div>
       <div class="inline-controls">
        <label class="toggle"><input id="vertexEdit" type="checkbox">ç·¨é›†</label>
        <label class="toggle"><input id="lockSize" type="checkbox">å›ºå®š</label>
        <label class="toggle"><input id="showVertices" type="checkbox" checked>è¡¨ç¤º</label>
        <label class="color-pick">è‰² <input id="color" type="color" value="#2563eb"/></label>
       </div>

       <div style="display:flex; gap:6px; flex-wrap:wrap; margin-top:6px;">
        <button id="dup" title="é¸æŠå›³å½¢ã‚’ã‚³ãƒ”ãƒ¼">
         â§‰ ã‚³ãƒ”ãƒ¼
        </button>
        <button id="front" title="å‰é¢ã¸">
         â¤´ æ‰‹å‰ã¸
        </button>
        <button id="back" title="èƒŒé¢ã¸">
         â¤µ å¥¥ã¸
        </button>
        <button id="flipH" title="å·¦å³åè»¢">
         â‡” åè»¢
        </button>
        <button id="flipV" title="ä¸Šä¸‹åè»¢">
         â‡• åè»¢
        </button>
       </div>
      </div>
      <div class="group">
  <div class="split-tools" style="display:flex; align-items:center; gap:8px; flex-wrap:nowrap;">
    <button data-tool="splitLine" title="ç›´ç·šã§åˆ†å‰²ï¼ˆè¤‡æ•°å›³å½¢ã«ã‚‚å¯¾å¿œï¼‰">
      <span class="icon">âœ‚ï¸</span>
    </button>

    <label class="toggle" title="åˆ†å‰²ç·šã‚’æ–¹çœ¼ã«å¸ç€ã•ã›ã‚‹" style="display:flex; align-items:center; gap:6px;">
      <input id="splitGridSnap" type="checkbox"/>ç›´ç·š
    </label>

    <label class="toggle" style="display:flex; align-items:center; gap:6px;">
      <input id="splitContinuous" type="checkbox"/>é€£ç¶š
    </label>
  </div>
</div>
     </div>
    </div>
   </aside>
   <div id="lightbox">
    <button class="lb-close" id="lbClose">
     é–‰ã˜ã‚‹
    </button>
    <div class="lb-nav lb-prev" id="lbPrev">
     â€¹
    </div>
    <img alt="preview" id="lbImg"/>
    <div class="lb-nav lb-next" id="lbNext">
     â€º
    </div>
   </div>
  </main>
  <script>
	if ("serviceWorker" in navigator) {
    navigator.serviceWorker.register("./sw.js");
    }
   const board=document.getElementById('board');window.board = board;
  const drawCanvas=document.getElementById('drawCanvas');
  const cursorCanvas=document.getElementById('cursorCanvas');
  const eraserSizeSel = document.getElementById('eraserSize');
  drawCanvas.style.touchAction = 'none'; // ãƒãƒ«ãƒã‚¿ãƒƒãƒï¼ãƒ”ãƒ³ãƒç„¡åŠ¹åŒ–

  
  const svgNS='http://www.w3.org/2000/svg';
  const ctx=drawCanvas.getContext('2d');
  const cctx=cursorCanvas.getContext('2d'); 
  const pxPerCm=parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--grid-cm'))||37.7952755906;
	const THEME_SHAPE_COLOR = { light:'#2563eb', dark:'#facc15' };
	function getTheme(){ return document.documentElement.getAttribute('data-theme') || 'light'; }
  function el(name, attrs={}){ const n=document.createElementNS(svgNS,name); for(const k in attrs) n.setAttribute(k, attrs[k]); return n; }
  function uid(){ return 's'+Math.random().toString(36).slice(2,9); }

  
  const state={
    tool:'edit',
    gridPx:pxPerCm,
    gridOffset:0, 
    snapTol:16,
    shapes:[],
    notes:[],   
    drawings:[],
    eraseStrokes:[], 
    sel:null,          
    selNoteId:null,    
    dragging:null,
    lockSize:false,
    vertexEdit:false,
    history:[],
    future:[],
    penColor:'#1f2937',
    eraserMode:'pixel',
    eraserSize: 14,
    splitPreview:null,
    splitGridSnap:false,
	splitContinuous:false,
    pointerCaptured:false,
    dpr: Math.max(1, window.devicePixelRatio || 1),
    pointerPos:{x:0,y:0},
    splitStart:null,
    splitPinEl:null,
    actions: [], 
		drawingPointerId: null,
    penThickness: 1.5,
    penStraight: false,      
  	lineAnchor: null,
	_opPushed: false,
  };window.state = state;
  
	state.snaps = []; 

	const uiB = {
  	tab: document.getElementById('asideBTab'),
  	list: document.getElementById('thumbList'),
  	shot: document.getElementById('shot'),
  	saveAll: document.getElementById('saveAll'),
  	swap: document.getElementById('swapSidebars'),
  	lb: document.getElementById('lightbox'),
  	lbImg: document.getElementById('lbImg'),
  	lbPrev: document.getElementById('lbPrev'),
  	lbNext: document.getElementById('lbNext'),
  	lbClose: document.getElementById('lbClose')
	};
  function refreshSidebarTabIcons(){
  	const swapped   = document.body.classList.contains('swap-sidebars');
  	const leftCollapsed  = document.body.classList.contains('asideB-collapsed');
  	const rightCollapsed = document.body.classList.contains('aside-collapsed');
    
  	uiB.tab.textContent = (swapped
    	? (leftCollapsed ? 'â—€' : 'â–¶')
    	: (leftCollapsed ? 'â–¶' : 'â—€'));

  	
  	const rightTab = document.getElementById('asideTab');
  	if (rightTab){
    	rightTab.textContent = (swapped
      	? (rightCollapsed ? 'â–¶' : 'â—€')
      	: (rightCollapsed ? 'â—€' : 'â–¶'));
    }
  }
  
  function bindMainTransitionRelayout(){
  const m = document.querySelector('main');
  if (!m) return;
  m.addEventListener('transitionend', (e)=>{
    if (e.propertyName === 'grid-template-columns') {
      scheduleRelayout();
      refreshSidebarTabIcons();
    	}
  	});
	}
  	
	let lbIndex = 0;
  
  
	function cssVar(name, fallback='') {
  	const v = getComputedStyle(document.documentElement).getPropertyValue(name);
  	return (v && v.trim()) || fallback;
	}
	
	function htmlToPlainText(html) {
  	const div = document.createElement('div');
  	div.innerHTML = html || '';
  	
  	div.querySelectorAll('br').forEach(br => br.replaceWith('\n'));
  	return (div.textContent || '').replace(/\r\n/g, '\n');
	}
	
	function wrapLines(text, maxWidth, font) {
  	const c = document.createElement('canvas');
  	const g = c.getContext('2d');
  	g.font = font;
  	const words = text.split(/\s+/);
  	const lines = [];
  	let cur = '';
  	const push = () => { lines.push(cur); cur=''; };

  	for (let i=0;i<words.length;i++){
    	const tryStr = cur ? (cur + ' ' + words[i]) : words[i];
    	if (g.measureText(tryStr).width <= maxWidth) {
      	cur = tryStr;
    	} else {
      	if (cur) push();
      	
      	if (g.measureText(words[i]).width > maxWidth) {
        	let chunk='', rest=words[i];
        	while (g.measureText(rest).width > maxWidth) {
          	let lo=1, hi=rest.length, cut=1;
          	while (lo<=hi){
            	const mid=(lo+hi)>>1;
            	if (g.measureText(rest.slice(0,mid)).width <= maxWidth){ cut=mid; lo=mid+1; } else hi=mid-1;
          	}
          	lines.push(rest.slice(0,cut));
          	rest = rest.slice(cut);
        	}
        	cur = rest;
      	} else {
        	cur = words[i];
      	}
    	}
  	}
  	if (cur) push();
  	
  	return lines.map(l => l.split('\n')).flat();
	}

	
	async function captureViewportPNG(){
  	const svgEl = board;
  	const {width:W, height:H} = svgEl.getBoundingClientRect();

  	
  	const grid = document.getElementById('gridLayer')?.outerHTML || '';
  	const shapes = document.getElementById('shapesLayer')?.outerHTML || '';

  	
  	const notes = state.notes || [];
  	const noteYellow = cssVar('--note-yellow', '#fffbe6');
  	const noteBlue   = cssVar('--note-blue',   '#e6f3ff');
  	const notePink   = cssVar('--note-pink',   '#ffeaf1');
  	const btnBorder  = cssVar('--btn-border',  '#e5e7eb');
  	const textColor  = cssVar('--text',        '#111827');

  	
  	const fontPx = (font)=> font==='s' ? 13 : (font==='l' ? 24 : 17); 
  	const noteFill = (c)=> c==='blue'?noteBlue : c==='pink'?notePink : noteYellow;

  	
  	const padX = 8, padY = 8, lineGap = 4;

  	
  	function noteTextSVG(n){
    	const plain = htmlToPlainText(n.html||'');
    	const fpx = fontPx(n.font);
    	
    	const innerW = Math.max(0, (n.w - padX*2));
    	const lines = wrapLines(plain, innerW, `${fpx}px system-ui, -apple-system, Segoe UI, Roboto, sans-serif`);
    	
    	const lh = Math.round(fpx * 1.25);
    	let y = n.y + padY + fpx; 
    	const tspans = lines.map(l=>{
      	const t = `<tspan x="${n.x + padX}" y="${y}">${String(l).replace(/&/g,'&amp;').replace(/</g,'&lt;')}</tspan>`;
      	y += lh + lineGap;
      	return t;
    	}).join('');
    	return `<text fill="${textColor}" font-size="${fpx}" font-family="system-ui,-apple-system,Segoe UI,Roboto,sans-serif">${tspans}</text>`;
  	}

  	const noteSVG = notes.map(n=>{
    	const fill = noteFill(n.color);
    	const border = btnBorder;
    	const rx = 8;
    	return [
      	`<rect x="${n.x}" y="${n.y}" width="${n.w}" height="${n.h}" rx="${rx}" ry="${rx}" fill="${fill}" stroke="${border}" />`,
      	noteTextSVG(n)
    	].join('');
  	}).join('');

  	const safeSVG = `
  	<svg xmlns="http://www.w3.org/2000/svg" width="${Math.ceil(W)}" height="${Math.ceil(H)}">
    	<g id="gridLayer">${grid.replace(/^[\s\S]*?<g[^>]*?>|<\/g>\s*$/g,'')}</g>
    	<g id="shapesLayer">${shapes.replace(/^[\s\S]*?<g[^>]*?>|<\/g>\s*$/g,'')}</g>
    	<g id="notesLayer">${noteSVG}</g>
  	</svg>`.trim();

  	
  	const svgBlob = new Blob([safeSVG], {type: 'image/svg+xml'});
  	const svgURL = URL.createObjectURL(svgBlob);
  	const img = await new Promise(res=>{
    	const im = new Image();
    	im.onload = ()=>res(im);
    	im.src = svgURL;
  	});

  	
  	const c = document.createElement('canvas');
  	c.width = Math.ceil(W); c.height = Math.ceil(H);
  	const g = c.getContext('2d');
  	g.fillStyle = getComputedStyle(document.body).getPropertyValue('--panel-bg') || '#fff';
  	g.fillRect(0,0,c.width,c.height);
  	g.drawImage(img, 0, 0, c.width, c.height);       
  	g.drawImage(drawCanvas, 0, 0, c.width, c.height); 
  	URL.revokeObjectURL(svgURL);

  	return c.toDataURL('image/png');
	}
 
  function addSnap(dataURL){
  	if (state.snaps.length >= 7) {
    	alert('ä¿å­˜ã§ãã‚‹ã®ã¯æœ€å¤§7æšã¾ã§ã§ã™ã€‚å¤ã„ã‚¹ãƒŠãƒƒãƒ—ã‚’å‰Šé™¤ã—ã¦ãã ã•ã„ã€‚');
    	return;
  	}
  	const id = 'snap_'+Date.now()+Math.random().toString(36).slice(2,6);
  	state.snaps.push({id, dataURL, created: Date.now()});
  	renderSnaps();

  	
  	if (state.snaps.length >= 7 && uiB.shot) uiB.shot.disabled = true;
	}

	
	function reevaluateShotButton(){
  	if (!uiB.shot) return;
  	uiB.shot.disabled = state.snaps.length >= 7;
	}
  
	
	function renumberThumbCaptions() {
  	const thumbs = uiB.list.querySelectorAll('.thumb');
  	thumbs.forEach((el, i) => {
    	const cap = el.querySelector('.cap');
    	if (cap) cap.textContent = String(i + 1);
  	});
	}

	
	function openLightboxById(id) {
  	const idx = state.snaps.findIndex(s => s.id === id);
  	if (idx >= 0) openLightbox(idx);
	}
  
	function renderSnaps(){
  	uiB.list.innerHTML = '';

  	state.snaps.forEach((s, idx) => {
    	const box = document.createElement('div');
    	box.className = 'thumb';
    	box.dataset.id = s.id;

    	
    	const grab = document.createElement('div');
    	grab.className = 'grab';
    	grab.title = 'ãƒ‰ãƒ©ãƒƒã‚°ã§ä¸¦ã¹æ›¿ãˆ';
    	grab.textContent = 'â‰¡';

    	const cap = document.createElement('div');
    	cap.className = 'cap';
    	cap.textContent = (idx + 1);

    	const img = document.createElement('img');
    	img.src = s.dataURL;
    	img.alt = 'snapshot ' + (idx + 1);

    	const del = document.createElement('button');
    	del.className = 'del';
    	del.textContent = 'ğŸ—‘';
    	del.title = 'ã“ã®ç”»åƒã‚’å‰Šé™¤';
    	del.setAttribute('aria-label', 'ã“ã®ã‚¹ãƒŠãƒƒãƒ—ã‚’å‰Šé™¤');
    	del.addEventListener('click', (e)=>{
      	e.stopPropagation();
      	state.snaps = state.snaps.filter(x => x.id !== s.id);
      	renderSnaps();
        reevaluateShotButton();
    	});

    	
    	img.addEventListener('click', () => openLightboxById(s.id));

    	box.appendChild(grab);
    	box.appendChild(cap);
    	box.appendChild(img);
    	box.appendChild(del);
    	uiB.list.appendChild(box);

    	
    	attachDirectReorder(grab, box);
  	});

  	renumberThumbCaptions();
    reevaluateShotButton();
	}
	
	function syncSnapsFromDOM(){
  	const ids = [...uiB.list.querySelectorAll('.thumb')].map(x => x.dataset.id);
  	state.snaps = ids.map(id => state.snaps.find(s => s.id === id));
	}

	
	function attachDirectReorder(handleEl, rowEl){
  	let dragging = false;
  	let pointerId = null;

  	const onPointerMove = (e) => {
    	if (!dragging) return;
    	e.preventDefault();

    	const y = e.clientY;
    	const after = getAfterElement(uiB.list, y);
    	if (after == null) uiB.list.appendChild(rowEl);
    	else uiB.list.insertBefore(rowEl, after);

    	
    	const r = uiB.list.getBoundingClientRect();
    	const margin = 24;
    	if (y < r.top + margin) uiB.list.scrollTop -= 12;
    	else if (y > r.bottom - margin) uiB.list.scrollTop += 12;
  	};

  	const onPointerUpOrCancel = (e) => {
    	if (e.pointerId !== pointerId) return;
    	try { handleEl.releasePointerCapture(pointerId); } catch(_){}
    	pointerId = null;

    	if (dragging) {
      	dragging = false;
      	uiB.list.classList.remove('dragging');
      	rowEl.classList.remove('dragging');
      	syncSnapsFromDOM();
      	renumberThumbCaptions();
    	}

    	window.removeEventListener('pointermove', onPointerMove, {passive:false});
    	window.removeEventListener('pointerup', onPointerUpOrCancel, {passive:false});
    	window.removeEventListener('pointercancel', onPointerUpOrCancel, {passive:false});
  	};

  	handleEl.addEventListener('pointerdown', (e) => {
    	e.preventDefault(); 
    	pointerId = e.pointerId;
    	try { handleEl.setPointerCapture(pointerId); } catch(_){}

    	dragging = true;
    	uiB.list.classList.add('dragging');
    	rowEl.classList.add('dragging');

    	window.addEventListener('pointermove', onPointerMove, {passive:false});
    	window.addEventListener('pointerup', onPointerUpOrCancel, {passive:false});
    	window.addEventListener('pointercancel', onPointerUpOrCancel, {passive:false});
  	}, {passive:false});
	}

	
	function getAfterElement(container, y){
  	const els = [...container.querySelectorAll('.thumb:not(.dragging)')];
  	let closest = {offset: Number.NEGATIVE_INFINITY, node: null};
  	for (const el of els){
    	const box = el.getBoundingClientRect();
    	const offset = y - (box.top + box.height/2);
    	if (offset < 0 && offset > closest.offset){
      	closest = {offset, node: el};
    	}
  	}
  	return closest.node;
	}

  function openLightbox(index){
  	if(!state.snaps.length) return;
  	lbIndex = Math.max(0, Math.min(index, state.snaps.length-1));
  	uiB.lbImg.src = state.snaps[lbIndex].dataURL;
  	uiB.lb.classList.add('show');
	}
	function closeLightbox(){ uiB.lb.classList.remove('show'); }
	function lbNext(){ if(!state.snaps.length) return; lbIndex = (lbIndex+1)%state.snaps.length; uiB.lbImg.src = state.snaps[lbIndex].dataURL; }
	function lbPrev(){ if(!state.snaps.length) return; lbIndex = (lbIndex-1+state.snaps.length)%state.snaps.length; uiB.lbImg.src = state.snaps[lbIndex].dataURL; }

	
	(function(){
  	let sx=0, sy=0;
  	uiB.lb?.addEventListener('touchstart', e=>{ const t=e.touches[0]; sx=t.clientX; sy=t.clientY; }, {passive:true});
  	uiB.lb?.addEventListener('touchend', e=>{
    	const t=e.changedTouches[0]; const dx=t.clientX-sx, dy=t.clientY-sy;
    	if(Math.abs(dx)>60 && Math.abs(dy)<80){ dx<0 ? lbNext() : lbPrev(); }
  	}, {passive:true});
	})();
  
  uiB.shot.addEventListener('click', async ()=>{
  	const url = await captureViewportPNG();
  	addSnap(url);
	});
	
  window.addEventListener('pointerup', (e)=>{ try{ endDrawingIfMatches(e);}catch(_){}} , {passive:true});
  window.addEventListener('pointercancel', (e)=>{ try{ endDrawingIfMatches(e);}catch(_){}} , {passive:true});
uiB.saveAll.addEventListener('click', shareAllSnaps);
	uiB.tab.addEventListener('click', ()=>{
const collapsed = document.body.classList.toggle('asideB-collapsed');
  	scheduleRelayout();           
  	refreshSidebarTabIcons();     
		drawGrid();
  	render();
  	redrawCanvas();
  	redrawCursorOverlay();
	
  requestAnimationFrame(()=>requestAnimationFrame(()=>{
    try{ ensureLayout(); }catch(_){}
    try{ drawGrid(); }catch(_){}
    try{ render(); }catch(_){}
    try{ redrawCanvas(); }catch(_){}
    try{ redrawCursorOverlay(); }catch(_){}
  }));
});
	document.getElementById('swapSidebars').addEventListener('click', ()=>{
document.body.classList.toggle('swap-sidebars');
  	scheduleRelayout();
  	refreshSidebarTabIcons();
    drawGrid();
  	render();
  	redrawCanvas();
  	redrawCursorOverlay();
	
  requestAnimationFrame(()=>requestAnimationFrame(()=>{
    try{ ensureLayout(); }catch(_){}
    try{ drawGrid(); }catch(_){}
    try{ render(); }catch(_){}
    try{ redrawCanvas(); }catch(_){}
    try{ redrawCursorOverlay(); }catch(_){}
  }));
});

	
	uiB.lbClose.addEventListener('click', closeLightbox);
	uiB.lbNext.addEventListener('click', lbNext);
	uiB.lbPrev.addEventListener('click', lbPrev);
	uiB.lb.addEventListener('click', (e)=>{ if(e.target===uiB.lb) closeLightbox(); }); 
   
	let suppressPenAutoSelect = false; 
  // ==== Pen/Eraser quick toggle constants ====
const PEN_THIN  = 1.5;   // æ—¢å®šã®ç´°
const PEN_THICK = 4.0;   // å¥½ã¿ã§èª¿æ•´ï¼šå¤ª

// æ¶ˆã—ã‚´ãƒ ã®æ®µéšï¼ˆpxï¼‰: å°/ä¸­/å¤§
const ERASER_STEPS = [10, 18, 28];

// ãƒœã‚¿ãƒ³è¡¨ç¤ºãƒ†ã‚­ã‚¹ãƒˆ
function penLabelFrom(value){
  const v = Number(value||0);
  return (Math.abs(v - PEN_THIN) < 0.01) ? 'ç´°' : 'å¤ª';
}
function eraserLabelFrom(value){
  const v = Number(value||0);
  if (v <= ERASER_STEPS[0]+0.01) return 'å°';
  if (v <= ERASER_STEPS[1]+0.01) return 'ä¸­';
  return 'å¤§';
}
  const ui={
    selType:document.getElementById('selType'), w:document.getElementById('w'), h:document.getElementById('h'), vh:document.getElementById('vh'),
    wLabel:document.getElementById('wLabel'), hLabel:document.getElementById('hLabel'),
    color:document.getElementById('color'), lockSize:document.getElementById('lockSize'),
    dup:document.getElementById('dup'), front:document.getElementById('front'), back:document.getElementById('back'),
    flipH:document.getElementById('flipH'), flipV:document.getElementById('flipV'),
    deleteShape:document.getElementById('deleteShape'),
    toolbar:document.getElementById('toolbar'), undo:document.getElementById('undo'), redo:document.getElementById('redo'),
    exportBtn:document.getElementById('export'), importInput:document.getElementById('import'),
    penColor:document.getElementById('penColor'), penThickness: document.getElementById('penThickness'),
  	penStraight:document.getElementById('penStraight'), eraserMode:document.getElementById('eraserMode'),
    gridSize:document.getElementById('gridSize'), splitGridSnap:document.getElementById('splitGridSnap'),
    vertexEdit:document.getElementById('vertexEdit'),
    resetBtn:document.getElementById('reset'),
    
    notePanel:document.getElementById('notePanel'),
    noteHdrColor:document.getElementById('noteHdrColor'),
    noteHdrSize:document.getElementById('noteHdrSize'),
    splitContinuous:document.getElementById('splitContinuous'),
    themeToggle:document.getElementById('themeToggle'),
    asideTab:document.getElementById('asideTab')
  };
  


  function ensureLayout(){
    const header = document.querySelector('header');
    const wrap = document.querySelector('.board-wrap');
    const vv = (window.visualViewport && visualViewport.height)
      ? visualViewport.height
      : window.innerHeight;
    const hHeader = header ? Math.ceil(header.getBoundingClientRect().height) : 0;
    const avail = Math.max(420, Math.floor(vv) - hHeader - 24 - 1);
    if (wrap) wrap.style.height = avail + 'px';
  }
  function scheduleRelayout(){
  	requestAnimationFrame(()=>{
    	ensureLayout();
    	drawGrid();
    	render();
    	redrawCanvas();
    	redrawCursorOverlay();
  	});
	}
  
  // ==== Inject quick toggle buttons next to selects ====
function injectToggleButtons(){
  const penSel   = document.getElementById('penThickness');
  const erSel    = document.getElementById('eraserSize');

  // ãƒšãƒ³å¤ªã•ãƒˆã‚°ãƒ«
  if (penSel && !document.getElementById('btnPenToggle')){
    const btn = document.createElement('button');
    btn.id = 'btnPenToggle';
    btn.type = 'button';
    btn.title = 'ãƒšãƒ³å¤ªã•ã‚’åˆ‡æ›¿ï¼ˆç´°â‡†å¤ªï¼‰';
    btn.textContent = penLabelFrom(penSel.value || state.penThickness || PEN_THIN);
    btn.style.marginLeft = '6px';

    btn.addEventListener('click', ()=>{
      const cur = Number(state.penThickness || penSel.value || PEN_THIN);
      const next = (Math.abs(cur - PEN_THIN) < 0.01) ? PEN_THICK : PEN_THIN;
      state.penThickness = next;
      penSel.value = String(next);
      setTool('draw');
      render();
      btn.textContent = penLabelFrom(next);
    });

    penSel.insertAdjacentElement('afterend', btn);
  }

  // æ¶ˆã—ã‚´ãƒ ã‚µã‚¤ã‚ºãƒˆã‚°ãƒ«
  if (erSel && !document.getElementById('btnEraserCycle')){
    const btn = document.createElement('button');
    btn.id = 'btnEraserCycle';
    btn.type = 'button';
    btn.title = 'ãƒ”ã‚¯ã‚»ãƒ«æ¶ˆã—ã‚´ãƒ ã®å¤§ãã•ã‚’åˆ‡æ›¿ï¼ˆå°â†’ä¸­â†’å¤§â†’â€¦ï¼‰';
    btn.textContent = eraserLabelFrom(erSel.value || state.eraserSize || ERASER_STEPS[0]);
    btn.style.marginLeft = '6px';

    btn.addEventListener('click', ()=>{
      // ç¾åœ¨å€¤ãŒã‚¹ãƒ†ãƒƒãƒ—ã«ã„ãªã„å ´åˆã¯ã€æœ€ã‚‚è¿‘ã„æ®µã«å¸ç€
      const cur = Number(state.eraserSize || erSel.value || ERASER_STEPS[0]);
      let idx = ERASER_STEPS.findIndex(s => Math.abs(s - cur) < 0.01);
      if (idx < 0){
        let best=0, d=1e9;
        ERASER_STEPS.forEach((s,i)=>{ const dd=Math.abs(s-cur); if(dd<d){ d=dd; best=i; } });
        idx = best;
      }
      const next = ERASER_STEPS[(idx + 1) % ERASER_STEPS.length];

      state.eraserSize = next;
      erSel.value = String(next);
      setTool('erase');
      redrawCursorOverlay();
      btn.textContent = eraserLabelFrom(next);
    });

    erSel.insertAdjacentElement('afterend', btn);
  }
}

// åˆæœŸåŒ–ã®çµ‚ç›¤ã§ä¸€åº¦ã ã‘æ³¨å…¥
injectToggleButtons();
  
  function setSvgSizeByClient(){
  const r = board.getBoundingClientRect();
  const w = Math.max(1, Math.floor(r.width));
  const h = Math.max(1, Math.floor(r.height));
  board.setAttribute('width', w);
  board.setAttribute('height', h);
  setupCanvasDPR(drawCanvas, ctx, w, h);
  setupCanvasDPR(cursorCanvas, cctx, w, h);
  return {w, h};
};
  function setupCanvasDPR(canvas, context, cssW, cssH){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    state.dpr = dpr;
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.width  = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);
    context.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  
  let __vpTick = null;
  function onViewportChange() {
    if (__vpTick) cancelAnimationFrame(__vpTick);
    __vpTick = requestAnimationFrame(()=>{
      ensureLayout();
      drawGrid();
      render();
      redrawCursorOverlay();
    });
  }

  
  function drawGrid(){
    while(board.firstChild) board.removeChild(board.firstChild);
    const {w,h}=setSvgSizeByClient();
    if(!w||!h) return;

    const grid = el('g', { id:'gridLayer' });
    const color = (getComputedStyle(document.documentElement).getPropertyValue('--grid-stroke')||'#bfdbfe').trim();
    const lw = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--grid-pt')) || 1.0;
    const g = state.gridPx;

    
    const pixelW = lw * state.dpr;
    const pxOffset = (Math.round(pixelW) % 2 === 1) ? 0.5 : 0;
    state.gridOffset = pxOffset;

    for(let x=0; x<=w+1; x+=g){
      const xx = x + pxOffset;
      grid.appendChild(el('line', { x1: xx, y1: 0, x2: xx, y2: h, stroke: color, 'stroke-width': lw, 'shape-rendering':'crispEdges' }));
    }
    for(let y=0; y<=h+1; y+=g){
      const yy = y + pxOffset;
      grid.appendChild(el('line', { x1: 0, y1: yy, x2: w, y2: yy, stroke: color, 'stroke-width': lw, 'shape-rendering':'crispEdges' }));
    }
    board.appendChild(grid);
    board.appendChild(el('g',{id:'shapesLayer'}));
    board.appendChild(el('g',{id:'handlesLayer'}));
    board.appendChild(el('g',{id:'textLayer'}));
  }
  function ensureLayers(){
    const ids=['gridLayer','shapesLayer','handlesLayer','textLayer'];
    for(const id of ids){
      if(!document.getElementById(id)) board.appendChild(el('g',{id}));
    }
  }

  
  function pt(e){
    const tgt = (e.currentTarget && e.currentTarget.getBoundingClientRect) ? e.currentTarget : board;
    const bb = tgt.getBoundingClientRect();
    return { x: e.clientX - bb.left, y: e.clientY - bb.top };
  }
  
  function ptBoard(e){
    const bb = board.getBoundingClientRect();
    return { x: e.clientX - bb.left, y: e.clientY - bb.top };
  }
  function ptsToAttr(pts){ return pts.map(p=>p.join(',')).join(' '); }
  function bbox(pts){ const xs=pts.map(p=>p[0]), ys=pts.map(p=>p[1]); const x=Math.min(...xs), y=Math.min(...ys), w=Math.max(...xs)-x, h=Math.max(...ys)-y; return {x,y,w,h}; }
  function centroid(pts){ const s=pts.reduce((a,p)=>({x:a.x+p[0],y:a.y+p[1]}),{x:0,y:0}); return {x:s.x/pts.length,y:s.y/pts.length}; }
  function dist(x1,y1,x2,y2){ const dx=x1-x2, dy=y1-y2; return Math.hypot(dx,dy); }
  function rotatePointsAround(pts, cx, cy, rad){
    const cos = Math.cos(rad), sin = Math.sin(rad);
    return pts.map(([x,y])=>{
      const dx = x - cx, dy = y - cy;
      return [ cx + dx*cos - dy*sin, cy + dx*sin + dy*cos ];
    });
  }

  
  function segI(A,B,C,D){
    const den=(B[0]-A[0])*(D[1]-C[1])-(B[1]-A[1])*(D[0]-C[0]);
    if(Math.abs(den)<1e-6) return null;
    const t=((C[0]-A[0])*(D[1]-C[1])-(C[1]-A[1])*(D[0]-C[0]))/den;
    const u=((C[0]-A[0])*(B[1]-A[1])-(C[1]-A[1])*(B[0]-A[0]))/den;
    if(t<0||t>1||u<0||u>1) return null;
    return {x:A[0]+t*(B[0]-A[0]), y:A[1]+t*(B[1]-A[1])};
  }
  function candidates(){
    const pts=[]; const segs=[];
    for(const sh of state.shapes){
      const n=sh.points.length;
      for(let i=0;i<n;i++){
        const a=sh.points[i], b=sh.points[(i+1)%n];
        pts.push(a);
        pts.push([(a[0]+b[0])/2,(a[1]+b[1])/2]);
        segs.push([a,b]);
      }
    }
    for(let i=0;i<segs.length;i++) for(let j=i+1;j<segs.length;j++){ const I=segI(segs[i][0],segs[i][1],segs[j][0],segs[j][1]); if(I) pts.push([I.x,I.y]); }
    candidates._segs=segs; return pts;
  }
  function projectPointToSeg(p,a,b){
    const ax=a[0], ay=a[1], bx=b[0], by=b[1];
    const abx=bx-ax, aby=by-ay; const apx=p.x-ax, apy=p.y-ay; const ab2=abx*abx+aby*aby; if(ab2===0) return null;
    let t=(apx*abx+apy*aby)/ab2; if(t<0||t>1) return null; const x=ax+t*abx, y=ay+t*aby; const d=dist(p.x,p.y,x,y); return {x,y,d};
  }
  function projectToSegments(x,y){
    const segs=candidates._segs||[]; let best=null, bestd=state.snapTol+1;
    for(const s of segs){ const pr=projectPointToSeg({x,y}, s[0], s[1]); if(pr && pr.d<bestd){ best=pr; bestd=pr.d; } }
    return best && best.d<=state.snapTol?{x:best.x,y:best.y}:null;
  }

  function snapPoint(x,y){
    const off = state.gridOffset || 0, g=state.gridPx;
    const pts=candidates();
    const gx=Math.round((x-off)/g)*g + off, gy=Math.round((y-off)/g)*g + off; pts.push([gx,gy]);
    let best=null, bestd=state.snapTol+1;
    for(const c of pts){ const d=dist(x,y,c[0],c[1]); if(d<bestd){ bestd=d; best={x:c[0],y:c[1]}; }
    }
    return bestd<=state.snapTol?best:null;
  }
  function snapPointWithProjection(x,y){
    const s = snapPoint(x,y);
    if (s) return s;
    const pr = projectToSegments(x,y);
    return pr || null;
  }

  function nearestFrame(x,y){
    const W=board.clientWidth, H=board.clientHeight;
    const dTop=Math.abs(y-0), dBottom=Math.abs(H-y), dLeft=Math.abs(x-0), dRight=Math.abs(W-x);
    const m=Math.min(dTop,dBottom,dLeft,dRight);
    if(m===dTop) return {x:x,y:0,d:m,axis:'h',value:0};
    if(m===dBottom) return {x:x,y:H,d:m,axis:'h',value:H};
    if(m===dLeft) return {x:0,y:y,d:m,axis:'v',value:0};
    return {x:W,y:y,d:m,axis:'v',value:W};
  }

  
  function snapDeltaForMove(dx, dy, initPts){
    const off = state.gridOffset || 0;
    const g   = state.gridPx;
    const tol = state.snapTol || 16;
    let bestDx = dx, bestDy = dy;
    let bestDist = tol + 1;
    for (const [x0,y0] of initPts) {
      const x = x0 + dx;
      const y = y0 + dy;
      const gx = Math.round((x - off)/g)*g + off;
      const gy = Math.round((y - off)/g)*g + off;
      const fixX = Math.abs(x - gx) <= tol ? gx - x : 0;
      const fixY = Math.abs(y - gy) <= tol ? gy - y : 0;
      const d = Math.hypot(fixX, fixY);
      if (d > 0 && d < bestDist) {
        bestDist = d;
        bestDx = dx + fixX;
        bestDy = dy + fixY;
      }
    }
    return {dx: bestDx, dy: bestDy};
  }

  
  function gridPoint(n, m){
    const off = state.gridOffset || 0;
       const g = state.gridPx;
    return [n*g + off, m*g + off];
  }
  function addShape(type){
    const g=state.gridPx, off=state.gridOffset||0, cx=off+g*2, cy=off+g*2; let pts=[];
    if(type==='rect'){
	  const g = state.gridPx;
	  const off = state.gridOffset || 0;
	  const w = 7 * g;  // ã‚ˆã“
	  const h = 5 * g;  // ãŸã¦
	
	  // ã‚°ãƒªãƒƒãƒ‰ã®ä¸­å¿ƒã«åˆã‚ã›ã¦é…ç½®ï¼ˆä¸­å¿ƒ = cx, cyï¼‰
	  const x0 = (cx - w/2)+4.5*g;
	  const y0 = (cy - h/2)+1.5*g;
	
	  pts = [
	    [x0,      y0],      // å·¦ä¸Š
	    [x0 + w,  y0],      // å³ä¸Š
	    [x0 + w,  y0 + h],  // å³ä¸‹
	    [x0,      y0 + h]   // å·¦ä¸‹
	  ];
	}

    if (type === 'tri') {
  		
  		
  		const grid   = state.gridPx;
  		const base   = 6 * grid;     
  		const height = 4 * grid;     
  		const dx     = -1 * grid;    

  		
  		const cx2 = cx + (2+2) * grid;
  		const cy2 = cy + (1+1) * grid;

  		
  		const x0 = cx2 - base / 2;       
  		const y0 = cy2 + height / 2;     

  		pts = [
    		[x0,            y0],           
    		[x0 + base,     y0],           
    		[x0 + base/2 + dx, y0 - height]
  		];
		}
   if(type==='trap'){
	  const v = Math.floor(Math.random()*4); // 0..3 ã®4é€šã‚Š
	  if(v===0){
	    // â‘  è¿½åŠ ã—ãŸå°å½¢ï¼ˆä¸Šåº•3, ä¸‹åº•9, é«˜ã•4ï¼‰ä½ç½®: å³3, ä¸‹1
	    const topL  = 3*g, baseL = 9*g, h = 4*g;
	    const topY = cy + 1*g;
	    const bottomY = topY + h;
	    const x0 = cx-1*g;                 // ä¸‹åº•å·¦ç«¯Bã®x
	    const B = [x0,            bottomY];
	    const C = [x0 + baseL,    bottomY];
	    const A = [x0 + 2*g,      topY];     // Aã¯Bã‚ˆã‚Šå³ã«2
	    const D = [A[0] + topL,   topY];     // Dã¯Cã‚ˆã‚Šå·¦ã«4ï¼ˆ9-4=5ã€A=2â†’D=5ã§æˆç«‹ï¼‰
	    pts = [A, D, C, B];                  // æ™‚è¨ˆå›ã‚Š
	}else if(v===1){
	  // â‘¡ æ–°ã—ã„å°å½¢ï¼šä¸Šåº•7ã€ä¸‹åº•4ã€é«˜ã•3
	  // æ¡ä»¶: é ‚ç‚¹AãŒå·¦ä¸Šã€ADã¨BCã¯å¹³è¡Œï¼ˆæ°´å¹³ï¼‰ã€CDã¯å‚ç›´
	  const topL  = 7 * g;      // ä¸Šåº•
	  const baseL = 4 * g;      // ä¸‹åº•
	  const h     = 3 * g;      // é«˜ã•
	
	  const topY = cy;          // ä¸Šè¾ºY
	  const bottomY = cy + h;   // ä¸‹è¾ºY
	
	  // å³å´ï¼ˆDã¨Cï¼‰ã®xã‚’åŸºæº–ã«æƒãˆã‚‹ã€‚CDãŒå‚ç›´ã«ãªã‚‹ã‚ˆã† C.x = D.x ã¨ã™ã‚‹
	  const rightX = cx + 4 * g+2*g; // ä½ç½®ã¯ä»»æ„ã®åŸºæº–ã€‚å¿…è¦ãªã‚‰ã“ã“ã§å…¨ä½“ã‚’å‹•ã‹ã™
	
	  // é ‚ç‚¹å®šç¾©ï¼ˆæ™‚è¨ˆå›ã‚Š: Aâ†’Dâ†’Câ†’Bï¼‰
	  const D = [rightX,          topY];        // å³ä¸Š
	  const C = [rightX,          bottomY];     // å³ä¸‹ï¼ˆDã¨åŒã˜xã§å‚ç›´ï¼‰
	  const A = [rightX - topL,   topY];        // å·¦ä¸Šï¼ˆAï¼‰
	  const B = [rightX - baseL,  bottomY];     // å·¦ä¸‹
	
	  pts = [A, D, C, B];
	}else if(v===2){
	    // â‘¢ ä¸Šåº•ãŒé•·ã„å°å½¢ï¼šä¸Šåº•8ã€ä¸‹åº•5ã€é«˜ã•5ï¼ˆä¸­å¿ƒåˆã‚ã›ï¼‰
	    const topL  = 7*g, baseL = 5*g, h = 5*g;
	    const topY = cy;
	    const bottomY = cy + h;
	    const x0 = cx+1*g;                       // ä¸‹åº•å·¦ç«¯B
	    const B = [x0,           bottomY];
	    const C = [x0 + baseL,   bottomY];
	    const topLeft = x0 + baseL/2 - topL/2; // ä¸Šä¸‹ã®ä¸­å¿ƒåˆã‚ã›
	    const A = [topLeft,       topY];
	    const D = [topLeft + topL, topY];
	    pts = [A, D, C, B];                  // æ™‚è¨ˆå›ã‚Š
	  }else{
	    // â‘£ ä¸‹åº•ãŒé•·ã„å°å½¢ï¼ˆç­‰è„šï¼‰ï¼šä¸Šåº•5ã€ä¸‹åº•8ã€é«˜ã•5ï¼ˆâ‘¢ã®ä¸Šä¸‹åè»¢ã«ç›¸å½“ï¼‰
	    const topL  = 4*g, baseL = 8*g, h = 5*g;
	    const topY = cy;
	    const bottomY = cy + h;
	    const x0 = cx;                       // ä¸‹åº•å·¦ç«¯B
	    const B = [x0,           bottomY];
	    const C = [x0 + baseL,   bottomY];
	    const topLeft = x0 + baseL/2 - topL/2; // ç­‰è„šãªã®ã§ä¸Šåº•ã¯ä¸‹åº•ã®ä¸­å¿ƒã«æƒãˆã‚‹
	    const A = [topLeft,       topY];
	    const D = [topLeft + topL, topY];
	    pts = [A, D, C, B];                  // æ™‚è¨ˆå›ã‚Š
	  }
	}

    if (type === 'para') {const g=state.gridPx;const off=state.gridOffset||0;const x0=off+(2-3+2)*g;const y0=off+(2+1+3)*g;const base=2*g;const height=4*g;const skew=3*g;pts=[[x0,y0],[x0+base,y0],[x0+base+skew,y0-height],[x0+skew,y0-height]];}
    if(type==='rh'){
      const g = state.gridPx;
      const off = state.gridOffset || 0;
      const cmPerGrid = g / pxPerCm;
      const short = Math.abs(cmPerGrid - 1) < 1e-3 ? 4 * pxPerCm : 4 * g;
      const long  = Math.abs(cmPerGrid - 1) < 1e-3 ? 8 * pxPerCm : 8 * g;
      const cxg = off + (3+3) * g;
      const cyg = off+4*g;
      const top    = [cxg,            cyg - short/2];
      const right  = [cxg + long/2,   cyg];
      const bottom = [cxg,            cyg + short/2];
      const left   = [cxg - long/2,   cyg];
      pts = [top, right, bottom, left];
    }

    const sh={id:uid(), type, points:pts, fill:ui.color.value, stroke:ui.color.value, userColored: false}; __assignLabels(sh);
    state.shapes.push(sh);
		selectShape(sh);       
		pushHistory();
		setTool('edit');       
		render();
  }

  
  function addNote(x,y){
    const dpx = Math.round(pxPerCm * 0.5); 
    const n={id:uid(), x, y, w:160 + dpx, h:80 + dpx, html:'ãƒ¡ãƒ¢', color:'yellow', font:'m'};
    state.notes.push(n);
    state.selNoteId=n.id;
    pushHistory(); render();
    setTool('edit');
  }
  function noteBgClass(color){
    return color==='pink' ? 'note-pink' : color==='blue' ? 'note-blue' : 'note-yellow';
  }
  function fontPt(font){ return font==='s' ? '10pt' : font==='l' ? '18pt' : '13pt'; }

  function renderNotes(){
    const textLayer=document.getElementById('textLayer');
    [...textLayer.querySelectorAll('foreignObject')].forEach(n=>n.remove());

    for(const n of state.notes){
      const fo=el('foreignObject',{x:n.x, y:n.y, width:n.w, height:n.h, 'data-nid':n.id});
      const wrap=document.createElement('div'); wrap.className='note-wrap';

      const div=document.createElement('div');
      div.className=`note ${noteBgClass(n.color)}`;
      div.contentEditable='true';
      div.style.fontSize = fontPt(n.font);
      div.innerHTML=n.html;

      const close=document.createElement('button');
      close.className='note-close';
      close.textContent='âœ•';
      close.title='ä»˜ç®‹ã‚’å‰Šé™¤';

      const grip=document.createElement('div'); grip.className='note-resize'; grip.title='ã‚µã‚¤ã‚ºå¤‰æ›´';

      wrap.appendChild(div);
      wrap.appendChild(close);
      wrap.appendChild(grip);
      fo.appendChild(wrap);
      textLayer.appendChild(fo);

      div.addEventListener('pointerdown',(e)=>{
        e.stopPropagation();
        state.selNoteId=n.id;
        updateNoteHeaderPanel();
        const startPt = ptBoard(e);
        state.dragging={mode:'notePending', note:n, start:startPt, ox:n.x, oy:n.y};
        try{board.setPointerCapture(e.pointerId);}catch(_){}
      });

      div.addEventListener('input', ()=>{ n.html=div.innerHTML; });
      div.addEventListener('blur', ()=>{ n.html=div.innerHTML; pushHistory(); });

      close.addEventListener('pointerdown', (e)=>{ e.stopPropagation(); });
      close.addEventListener('click', (e)=>{
        e.stopPropagation();
        state.notes = state.notes.filter(x=>x.id!==n.id);
        if(state.selNoteId===n.id) state.selNoteId=null;
        pushHistory(); render();
      });

      grip.addEventListener('pointerdown',(e)=>{
        e.stopPropagation();
        state.selNoteId=n.id;
        updateNoteHeaderPanel();
        state.dragging = { mode:'noteResize', note:n, start:ptBoard(e), ow:n.w, oh:n.h };
        try{board.setPointerCapture(e.pointerId);}catch(_){}
      });
    }
  }

  
  function render(){
    ensureLayers();
    const layer=document.getElementById('shapesLayer');
    const handles=document.getElementById('handlesLayer');
    layer.innerHTML=''; handles.innerHTML='';

    for(const sh of state.shapes){
      const p=el('polygon',{points:ptsToAttr(sh.points), fill:sh.fill, stroke:sh.stroke, 'stroke-linejoin':'round', class:'shape'+(state.sel&&state.sel.id===sh.id?' selected':'')});
      p.dataset.id=sh.id; layer.appendChild(p);
      if(state.sel && state.sel.id===sh.id){
        if(state.vertexEdit){
          sh.points.forEach((pt,i)=> handles.appendChild(el('circle',{cx:pt[0],cy:pt[1],r:12,class:'handle','data-vidx':i,'data-id':sh.id})));
        }else{
          const bb=bbox(sh.points);
          const hs=[
            {x:bb.x,y:bb.y,c:'nw'},{x:bb.x+bb.w/2,y:bb.y,c:'n'},{x:bb.x+bb.w,y:bb.y,c:'ne'},
            {x:bb.x,y:bb.y+bb.h/2,c:'w'},{x:bb.x+bb.w,y:bb.y+bb.h/2,c:'e'},
            {x:bb.x,y:bb.y+bb.h,c:'sw'},{x:bb.x+bb.w/2,y:bb.y+bb.h,c:'s'},{x:bb.x+bb.w,y:bb.y+bb.h,c:'se'}
          ];
          hs.forEach(h=>{const r=el('rect',{x:h.x-10,y:h.y-10,width:20,height:20,rx:4,class:'bbox-handle'}); r.dataset.id=sh.id; r.dataset.corner=h.c; handles.appendChild(r);});
          handles.appendChild(el('rect',{x:bb.x,y:bb.y,width:bb.w,height:bb.h,fill:'none',stroke:'#94a3b8','stroke-dasharray':'6 4'}));

          
          const topMid = { x: bb.x + bb.w/2, y: bb.y };
          const offset = 28; 
          handles.appendChild(el('line', {
            x1: topMid.x, y1: topMid.y,
            x2: topMid.x, y2: topMid.y - offset + 10,
            class: 'rot-stem'
          }));
          const rot = el('circle', {
            cx: topMid.x, cy: topMid.y - offset,
            r: 10, class: 'rot-handle'
          });
          rot.dataset.id = sh.id;
          rot.dataset.rot = '1';
          handles.appendChild(rot);
        }
      }
    }
    renderNotes(); __renderLabels(); updateBadges();
    updateNoteHeaderPanel();
    setCanvasInteractivity();
    redrawCanvas();
    redrawCursorOverlay();
  }

  
  function splitSnapOnce(p){
    const tol=state.snapTol;
    for(const sh of state.shapes){
      for(const v of sh.points){
        if(dist(p.x,p.y,v[0],v[1])<=tol) return {pt:{x:v[0],y:v[1]}, lock:null, anchor:'vertex'};
      }
    }
    if(state.splitGridSnap){
      const g=state.gridPx, off=state.gridOffset||0;
      const gx=Math.round((p.x-off)/g)*g + off, gy=Math.round((p.y-off)/g)*g + off;
      const dx=Math.abs(p.x-gx), dy=Math.abs(p.y-gy);
      if(Math.hypot(dx,dy)<=tol) return {pt:{x:gx,y:gy}, lock:null, anchor:'gridPoint'};
      if(dx<=tol && dx<=dy) return {pt:{x:gx,y:p.y}, lock:{axis:'v',value:gx}, anchor:'gridLine'};
      if(dy<=tol) return {pt:{x:p.x,y:gy}, lock:{axis:'h',value:gy}, anchor:'gridLine'};
    }
    const frame=nearestFrame(p.x,p.y);
    if(frame && frame.d<=tol) return {pt:{x:frame.x,y:frame.y}, lock:{axis:frame.axis,value:frame.value}, anchor:'frame'};
    return {pt:{x:p.x,y:p.y}, lock:null, anchor:'free'};
  }
  function splitSnapMove(p, existingLock, anchor, isShift){
    const tol=state.snapTol;
    if(existingLock){
      if(existingLock.axis==='h') return {pt:{x:p.x,y:existingLock.value}, lock:existingLock};
      if(existingLock.axis==='v') return {pt:{x:existingLock.value,y:p.y}, lock:existingLock};
    }
    for(const sh of state.shapes){
      for(const v of sh.points){
        if(dist(p.x,p.y,v[0],v[1])<=tol) return {pt:{x:v[0],y:v[1]}, lock:null};
      }
    }
    if(state.splitGridSnap){
      const g=state.gridPx, off=state.gridOffset||0;
      const gx=Math.round((p.x-off)/g)*g + off, gy=Math.round((p.y-off)/g)*g + off;
      const dx=Math.abs(p.x-gx), dy=Math.abs(p.y-gy);
      if(Math.hypot(dx,dy)<=tol) return {pt:{x:gx,y:gy}, lock:null};
      if(anchor!=='vertex' || isShift){
        if(dx<=tol && dx<=dy) return {pt:{x:gx,y:p.y}, lock:{axis:'v',value:gx}};
        if(dy<=tol)           return {pt:{x:p.x,y:gy}, lock:{axis:'h',value:gy}};
      }
    }
    if(anchor!=='vertex' || isShift){
      const frame=nearestFrame(p.x,p.y);
      if(frame && frame.d<=tol) return {pt:{x:frame.x,y:frame.y}, lock:{axis:frame.axis,value:frame.value}};
    }
    return {pt:{x:p.x,y:p.y}, lock:null};
  }

  
  function updateSplitPin(a){
    const hl=document.getElementById('handlesLayer');
    if(!hl) return;
    if(!a){
      if(state.splitPinEl){ state.splitPinEl.remove(); state.splitPinEl=null; }
      return;
    }
    if(!state.splitPinEl){
      state.splitPinEl = el('circle', { r:4, fill:'#ef4444', opacity:'1.0' });
      hl.appendChild(state.splitPinEl);
    }
    state.splitPinEl.setAttribute('cx', a.x);
    state.splitPinEl.setAttribute('cy', a.y);
  }
  function drawSplitPreview(a,b){
    ensureLayers();
    const hl=document.getElementById('handlesLayer');
    if(state.splitPreview) state.splitPreview.remove();
    const line=el('path',{d:`M ${a.x} ${a.y} L ${b.x} ${b.y}`, stroke:'#ef4444','stroke-dasharray':'6 4', fill:'none'});
    hl.appendChild(line); state.splitPreview=line;
    updateSplitPin(a);
  }

  
  function setTool(name){
    state.tool = name;
    if (name !== 'draw') state.__dragStart = null;
    [...ui.toolbar.querySelectorAll('button')].forEach(x=>x.classList.remove('active'));
    const btn = ui.toolbar.querySelector(`button[data-tool="${name}"]`);
    if (btn) btn.classList.add('active');
    setCanvasInteractivity();
    redrawCursorOverlay();
  }
  function selectShape(sh){ state.sel=sh; state.selNoteId=null; if(sh) ui.color.value=sh.fill; render(); }

  
  board.addEventListener('pointerdown', (e)=>{
    if(state.tool==='draw' || state.tool==='erase') return;
    const p=pt(e); state.pointerPos = p; redrawCursorOverlay();

    const target=e.target;
    const id=target && target.dataset ? target.dataset.id : null;
    const isVHandle   = target.classList && target.classList.contains('handle');
    const isBBoxHandle= target.classList && target.classList.contains('bbox-handle');
    const isRotHandle = target.classList && target.classList.contains('rot-handle');
    if (isRotHandle && state.sel){
      const c = centroid(state.sel.points);
      const a0 = Math.atan2(p.y - c.y, p.x - c.x);
      state.dragging = {
        mode: 'rotateFree',
        sh: state.sel,
        center: c,
        startAngle: a0,
        initPts: state.sel.points.map(q=>q.slice())
      };
      return;
    }
    if(state.tool==='text'){
      addNote(p.x, p.y);
      return;
    }
    if(state.tool==='splitLine'){
      const s=splitSnapOnce(p);
      state.dragging={mode:'split', a:s.pt, b:s.pt, lock:s.lock, anchor:s.anchor};
      drawSplitPreview(state.dragging.a, state.dragging.b);
      return;
    }

    if(state.sel && !state.vertexEdit && isBBoxHandle){
      if(state.lockSize) return;
      const bb0 = bbox(state.sel.points);
      state.dragging={
        mode:'bbox',
        sh: state.sel,
        corner:target.dataset.corner,
        start:p,
        initBB: bb0,
        initPts: state.sel.points.map(q=>q.slice())
      };
      return;
    }
    if(isVHandle){
      if(state.lockSize) return;
      state.dragging={mode:'vertex', sh:state.sel, vidx:+target.getAttribute('data-vidx')};
      return;
    }

    state.sel=null; state.selNoteId=null; updateNoteHeaderPanel(); render();

    if(id){
      const sh=state.shapes.find(s=>s.id===id);
      selectShape(sh);
      let anchorIdx = 0, best = 1e9;
      sh.points.forEach((q,i)=>{
        const d = Math.hypot(q[0]-p.x, q[1]-p.y);
        if(d < best){ best = d; anchorIdx = i; }
      });
      const anchorStart = sh.points[anchorIdx];
      const sStart = snapPointWithProjection(p.x, p.y) || {x:p.x, y:p.y};
      const anchorOffset = { ox: anchorStart[0] - sStart.x, oy: anchorStart[1] - sStart.y };

      state.dragging = {
        mode:'move',
        sh,
        startPt: p,
        initPts: sh.points.map(q=>q.slice()),
        anchorIdx,
        anchorStart,
        anchorOffset
      };
    }
  });

  
  drawCanvas.addEventListener('pointerdown', (e)=>{
  const p0 = pt(e);
  state.pointerPos = p0;

  // â˜… ä¸€æœ¬ç¸›ã‚Šï¼šæ—¢ã«ä»–ã®æŒ‡/ãƒšãƒ³ãŒæç”»ä¸­ãªã‚‰ç„¡è¦–
  if (state.tool === 'draw') {
    if (state.drawingPointerId !== null && state.drawingPointerId !== e.pointerId) {
      return; // 2æœ¬ç›®ä»¥é™ã¯åå¿œã—ãªã„
    }
    // ã“ã“ã§ã€Œã“ã®æŒ‡ã€ã‚’ãƒ­ãƒƒã‚¯
    state.drawingPointerId = e.pointerId;
  }
  redrawCursorOverlay();

  if (state.tool === 'draw'){
    e.preventDefault();

    if (state.penStraight) {
      if (!state._opPushed) { pushHistory(); state._opPushed = true; }

      state.lineAnchor = null;
      const snap = snapStartPoint(p0);
      state.__lineMode  = snap.mode;
      state.__lineStart = snap.start;
      state.__lineEdge  = snap.edge || null;
      state.__draggingStraight = true;

      try{ drawCanvas.setPointerCapture(e.pointerId); state.pointerCaptured=true; }catch(_){}
      return;
    }

    if (!state._opPushed) { pushHistory(); state._opPushed = true; }

    state.dragging = {
      mode:'draw',
      stroke:{ id: uid(), color: state.penColor, width: state.penThickness, pts: [[p0.x, p0.y]] }
    };
    try{ drawCanvas.setPointerCapture(e.pointerId); state.pointerCaptured=true; }catch(_){}
    redrawCanvas();
    return;
  }

  if (state.tool === 'erase'){
    e.preventDefault();
    handleEraserDown(e, p0);
    return;
  }
}, {passive:false});

  drawCanvas.addEventListener('pointermove', (e)=>{
  // â˜… ä¸€æœ¬ç¸›ã‚Šï¼šæç”»/ç›´ç·š/æ¶ˆã—ä¸­ã¯ã€Œãƒ­ãƒƒã‚¯ã—ãŸ pointerIdã€ä»¥å¤–ã¯ç„¡è¦–
  if ((state.tool === 'draw' || state.tool === 'erase')) {
    const isDrawing =
      (state.dragging && (state.dragging.mode === 'draw' ||
                          state.dragging.mode === 'erasePixel' ||
                          state.dragging.mode === 'eraseObject')) ||
      state.__draggingStraight;
    if (isDrawing && state.drawingPointerId !== null && e.pointerId !== state.drawingPointerId) {
      return;
    }
  }

  const p=pt(e);
  state.pointerPos = p;
  redrawCursorOverlay();

  // é€£ç¶šã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ¶ˆå»ï¼ˆæŠ¼ã—ã£ã±ï¼‰ä¸­
  if (state.dragging && state.dragging.mode === 'eraseObject'){
    e.preventDefault();
    if (!state._eraseObjRAF){
      const pos = p;
      const tol = state.eraserSize || 14;
      state._eraseObjRAF = requestAnimationFrame(()=>{
        state._eraseObjRAF = 0;
        const hit = eraseNearestDrawAction(pos, tol);
        if (hit) redrawCanvas();
      });
    }
    return;
  }

  if (state.tool === 'draw' && state.penStraight && state.__draggingStraight){
    e.preventDefault();
    let a = state.__lineStart;
    let b = p;
    if (state.__lineMode === 'edge' && state.__lineEdge){
      b = constrainOnEdge(p, state.__lineEdge);
    }
    state._previewStroke = { color: state.penColor, width: state.penThickness, pts: [[a.x, a.y],[b.x, b.y]] };
    redrawCanvas();
    return;
  }

  if(!state.dragging) { return; }
  if(state.dragging.mode==='draw'){
    e.preventDefault();
    addStrokePoint(p);
    redrawCanvas();
  }else if(state.dragging.mode==='erasePixel'){
    e.preventDefault();
    addErasePoint(p);
    redrawCanvas();
  }
}, {passive:false});

  drawCanvas.addEventListener('pointerup', onPointerUpOrCancel, {passive:false});
  drawCanvas.addEventListener('pointercancel', onPointerUpOrCancel, {passive:false});

  
  board.addEventListener('pointermove', (e)=>{
    const p=pt(e); state.pointerPos = p; redrawCursorOverlay();
    if(!state.dragging) { return; }
    const W=board.clientWidth, H=board.clientHeight;

    if(state.dragging.mode==='move'){
      const {sh, initPts, anchorStart, anchorOffset} = state.dragging;
      const baseDx = (p.x + anchorOffset.ox) - anchorStart[0];
      const baseDy = (p.y + anchorOffset.oy) - anchorStart[1];
      const {dx, dy} = snapDeltaForMove(baseDx, baseDy, initPts);
      const moved = initPts.map(([x0,y0]) => [x0 + dx, y0 + dy]);
      sh.points = clampToBoard(moved, W, H);
      render();
    }else if(state.dragging.mode==='vertex'){
      const {sh,vidx}=state.dragging;
      const g = state.gridPx, off = state.gridOffset || 0;
      const gxRound = Math.round((p.x - off) / g) * g + off;
      const gyRound = Math.round((p.y - off) / g) * g + off;
      const gx = Math.abs(p.x - gxRound) <= (state.snapTol || 16) ? gxRound : p.x;
      const gy = Math.abs(p.y - gyRound) <= (state.snapTol || 16) ? gyRound : p.y;
      const pts = sh.points.slice(); pts[vidx] = [gx, gy];
      sh.points=clampToBoard(pts, W, H); render();
    }else if(state.dragging.mode==='bbox'){
      const {sh,corner,initBB,initPts}=state.dragging;
      resizeByBBoxSnap(sh, corner, initBB, initPts, {x:p.x, y:p.y});
      sh.points=clampToBoard(sh.points, W, H); render();
    }else if(state.dragging.mode==='notePending'){
      const {note,start}=state.dragging;
      if (Math.hypot(p.x - start.x, p.y - start.y) > 3) state.dragging.mode='noteMove';
    }else if(state.dragging.mode==='noteMove'){
      const {note,start,ox,oy}=state.dragging;
      note.x = ox + (p.x-start.x);
      note.y = oy + (p.y-start.y);
      renderNotes();
    }else if(state.dragging.mode==='noteResize'){
      const {note,start,ow,oh}=state.dragging;
      note.w = Math.max(80, ow + (p.x-start.x));
      note.h = Math.max(40, oh + (p.y-start.y));
      renderNotes();
    }else if(state.dragging.mode==='rotateFree'){
	  const { sh, center, startAngle, initPts } = state.dragging;
	  let ang = Math.atan2(p.y - center.y, p.x - center.x) - startAngle;
	  if (!e.shiftKey) {
	    const step = 15 * Math.PI / 180;
	    ang = Math.round(ang / step) * step;
	  }
	
	  sh.points = rotatePointsAround(initPts, center.x, center.y, ang);
	  render();
	}else if(state.dragging.mode==='split'){
      const isShift=!!e.shiftKey;
     const snap = splitSnapMove(p, state.dragging.lock, state.dragging.anchor, isShift, !!state.cutAlongEdge);
      state.dragging.b=snap.pt;
      if(state.dragging.lock==null && snap.lock) state.dragging.lock=snap.lock;
      drawSplitPreview(state.dragging.a, state.dragging.b);
    }
  }, {passive:false});

 function onPointerUpOrCancel(e){
  if (state.dragging && state.dragging.mode === 'eraseObject'){
    // é€£ç¶šå‰Šé™¤ã®çµ‚äº†ã€‚ã“ã“ã§å±¥æ­´ã«ç©ã‚€
    if (!state._opPushed) pushHistory();
    state._opPushed = false;
    state.dragging = null;
    try { drawCanvas.releasePointerCapture(e.pointerId); } catch(_){}
    redrawCanvas();
    // ä¸‹ã®å…±é€šç‰‡ä»˜ã‘ã«è½ã¨ã—ã¦ã‚‚è‰¯ã„ãŒã€äºŒé‡ã§å•é¡Œã¯å‡ºãªã„
  }

  // â˜… ç›´ç·šãƒ‰ãƒ©ãƒƒã‚°ç¢ºå®šï¼ˆé ‚ç‚¹/è¾º/è‡ªç”±ã®ã„ãšã‚Œã§é–‹å§‹ã—ã¦ã‚‚çµ±ä¸€å‡¦ç†ï¼‰
  if (state.tool === 'draw' && state.penStraight && state.__draggingStraight) {
    const p = state.pointerPos || pt(e);
    let a = state.__lineStart;
    let b = p;
    if (state.__lineMode === 'edge' && state.__lineEdge) {
      b = constrainOnEdge(p, state.__lineEdge);   // è¾ºã«æ²¿ã£ã¦æ‹˜æŸ
    }
    state.actions.push({
      type: 'draw',
      color: state.penColor,
      width: state.penThickness,
      pts: [[a.x, a.y], [b.x, b.y]]
    });
	  
	// â˜… å±¥æ­´ï¼ˆé–‹å§‹æ™‚ã«ç©ã‚“ã§ã„ãªã‘ã‚Œã°ã“ã“ã§ï¼‰
  	if (!state._opPushed) pushHistory();
  	state._opPushed = false;
	  
    // ç‰‡ä»˜ã‘
    state._previewStroke      = null;
    state.__draggingStraight  = false;
    state.__lineMode          = null;
    state.__lineStart         = null;
    state.__lineEdge          = null;
    redrawCanvas();
    redrawCursorOverlay();
    // ã“ã“ã§ returnã€‚ä¸‹ã®æ±ç”¨å‡¦ç†ã«è½ã¨ã•ãªã„
    return;
  }

  	if(!state.dragging) return;
  	const m = state.dragging.mode;

  	if(m==='move' || m==='vertex' || m==='bbox' || m==='noteMove' || m==='noteResize' || m==='rotateFree'){ 
    	pushHistory(); 
  	}
  	if(m==='draw'){
	  finishStroke();
	  if (!state._opPushed) pushHistory();
	  state._opPushed = false;
	  redrawCanvas();
	}

  	if(m==='erasePixel'){
	  finishEraseStroke();
	  if (!state._opPushed) pushHistory();
	  state._opPushed = false;
	  redrawCanvas();
	}

  	if(m==='split'){ 
    	finishSplit(); pushHistory(); 
  	}

  	
  	try { drawCanvas.releasePointerCapture(e.pointerId); } catch(_) {}
  	try { board.releasePointerCapture(e.pointerId); } catch(_) {}

  	state.pointerCaptured = false;

  	if (state.drawingPointerId === e.pointerId) {
    	state.drawingPointerId = null;
  	}

  	state.dragging = null;
  	redrawCursorOverlay();
	}
  board.addEventListener('pointerup', onPointerUpOrCancel, {passive:false});
  board.addEventListener('pointercancel', onPointerUpOrCancel, {passive:false});
  window.addEventListener('pointerup', onPointerUpOrCancel, {passive:false});
  window.addEventListener('pointercancel', onPointerUpOrCancel, {passive:false});
  window.addEventListener('blur', onPointerUpOrCancel);

  
  function resizeByBBoxSnap(sh, corner, initBB, initPts, curPt){
    const g   = state.gridPx;
    const off = state.gridOffset || 0;
    const tol = state.snapTol || 16;

    let L = initBB.x;
    let T = initBB.y;
    let R = initBB.x + initBB.w;
    let B = initBB.y + initBB.h;

    const gxRound = Math.round((curPt.x - off) / g) * g + off;
    const gyRound = Math.round((curPt.y - off) / g) * g + off;
    const gx = Math.abs(curPt.x - gxRound) <= tol ? gxRound : curPt.x;
    const gy = Math.abs(curPt.y - gyRound) <= tol ? gyRound : curPt.y;

    if (corner.includes('e')) R = gx;
    if (corner.includes('w')) L = gx;
    if (corner.includes('s')) B = gy;
    if (corner.includes('n')) T = gy;

    const MIN = 5;
    if (R - L < MIN) R = L + MIN;
    if (B - T < MIN) B = T + MIN;

    const sx = (R - L) / initBB.w;
    const sy = (B - T) / initBB.h;
    const ox = initBB.x;
    const oy = initBB.y;

    sh.points = initPts.map(([x,y]) => [
      L + (x - ox) * sx,
      T + (y - oy) * sy
    ]);
  }

  function clampToBoard(pts, W, H){
    const bb=bbox(pts); let dx=0, dy=0;
    if(bb.x<0) dx=-bb.x; if(bb.y<0) dy=-bb.y;
    if(bb.x+bb.w>W) dx = W-(bb.x+bb.w);
    if(bb.y+bb.h>H) dy = H-(bb.y+bb.h);
    return pts.map(p=>[p[0]+dx, p[1]+dy]);
  }

  
  function setCanvasInteractivity(){
    const active = (state.tool==='draw' || state.tool==='erase');
    drawCanvas.style.pointerEvents = active ? 'auto' : 'none';
    drawCanvas.style.cursor = (state.tool==='draw') ? pencilCursor() : 'crosshair';
  }
  function pencilCursor(){
    const svg = encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none">
      <path d="M2 22l5.5-1.5L20 8 16 4 4.5 16.5 2 22z" fill="#444"/>
      <path d="M16 4l4 4" stroke="#222" stroke-width="2"/>
    </svg>`);
    return `url("data:image/svg+xml,${svg}") 0 16, crosshair`;
  }

  function redrawCanvas(){
	  const W = drawCanvas.width / state.dpr, H = drawCanvas.height / state.dpr;
	  ctx.clearRect(0,0,W,H);
	
	  // æ—¢å­˜ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆæç”»/æ¶ˆå»ï¼‰
	  for (const act of state.actions){
	    if (act.type === 'draw'){
	      ctx.save();
	      ctx.globalCompositeOperation = 'source-over';
	      ctx.lineWidth   = (act.width != null ? act.width : 2);
	      ctx.lineJoin    = 'round';
	      ctx.lineCap     = 'round';
	      ctx.strokeStyle = act.color;
	      const pts = act.pts;
	      if (pts && pts.length){
	        ctx.beginPath();
	        ctx.moveTo(pts[0][0], pts[0][1]);
	        for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0], pts[i][1]);
	        ctx.stroke();
	      }
	      ctx.restore();
	    } else if (act.type === 'erase'){
	      ctx.save();
	      ctx.globalCompositeOperation = 'destination-out';
	      ctx.lineWidth = act.radius;
	      ctx.lineCap   = 'round';
	      ctx.lineJoin  = 'round';
	      const pts = act.pts;
	      if (pts && pts.length){
	        ctx.beginPath();
	        ctx.moveTo(pts[0][0], pts[0][1]);
	        for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0], pts[i][1]);
	        ctx.stroke();
	      }
	      ctx.restore();
	    }
	  }
	
	  // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ãƒ•ãƒªãƒ¼ãƒãƒ³ãƒ‰ã®ãƒ©ã‚¤ãƒ–æç”»
	  if (state.dragging && state.dragging.mode === 'draw' && state.dragging.stroke){
	    const s = state.dragging.stroke;
	    ctx.save();
	    ctx.globalCompositeOperation = 'source-over';
	    ctx.lineWidth   = (s.width != null ? s.width : 2);
	    ctx.lineJoin    = 'round';
	    ctx.lineCap     = 'round';
	    ctx.strokeStyle = s.color;
	    const pts = s.pts;
	    if (pts && pts.length){
	      ctx.beginPath();
	      ctx.moveTo(pts[0][0], pts[0][1]);
	      for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0], pts[i][1]);
	      ctx.stroke();
	    }
	    ctx.restore();
	  }
	
	  // ãƒ”ã‚¯ã‚»ãƒ«æ¶ˆã—ã‚´ãƒ ã®ãƒ©ã‚¤ãƒ–æç”»
	  if (state.dragging && state.dragging.mode === 'erasePixel' && state.dragging.eraser){
	    const e = state.dragging.eraser;
	    ctx.save();
	    ctx.globalCompositeOperation = 'destination-out';
	    ctx.lineWidth = e.radius;
	    ctx.lineCap   = 'round';
	    ctx.lineJoin  = 'round';
	    const pts = e.pts;
	    if (pts && pts.length){
	      ctx.beginPath();
	      ctx.moveTo(pts[0][0], pts[0][1]);
	      for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0], pts[i][1]);
	      ctx.stroke();
	    }
	    ctx.restore();
	  }

  // â˜… ç›´ç·šãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã¯æœ€å¾Œã«ä¸€åº¦ã ã‘æãï¼ˆå¿…ãšæœ€å‰é¢ï¼‰
  if (state._previewStroke){
    const s = state._previewStroke;
    ctx.save();
    ctx.globalCompositeOperation = 'source-over';
    ctx.lineWidth   = s.width;
    ctx.lineJoin    = 'round';
    ctx.lineCap     = 'round';
    ctx.strokeStyle = s.color;
    ctx.beginPath();
    ctx.moveTo(s.pts[0][0], s.pts[0][1]);
    ctx.lineTo(s.pts[1][0], s.pts[1][1]);
    ctx.stroke();
    ctx.restore();
  }
}


  function addStrokePoint(p){ state.dragging.stroke.pts.push([p.x,p.y]); }
  function finishStroke(){
    const s = state.dragging.stroke;
    state.actions.push({type:'draw', color:s.color, width:s.width, pts:s.pts});
  }

  function handleEraserDown(e, p){
    const m=state.eraserMode;
    if(m==='clear'){
      state.actions = [];
      redrawCanvas(); pushHistory(); return;
    }
   if(m==='object'){
      // é€£ç¶šå‰Šé™¤ãƒ¢ãƒ¼ãƒ‰ã«å…¥ã‚‹
      state.dragging = { mode:'eraseObject' };
      try{ drawCanvas.setPointerCapture(e.pointerId); state.pointerCaptured=true; }catch(_){}

      // æŠ¼ç‚¹ãŒã—ãã„å€¤å†…ã®æ™‚ã ã‘æ¶ˆã™
      eraseNearestDrawAction(p, state.eraserSize || 14);
      redrawCanvas();
      return; // å±¥æ­´ã¯ pointerup ã§ç©ã‚€
    }


    if(m==='pixel'){
  		state.dragging = { mode:'erasePixel', eraser:{ pts:[[p.x,p.y]], radius: state.eraserSize } };
  		try{ drawCanvas.setPointerCapture(e.pointerId); state.pointerCaptured=true; }catch(_){}
  		redrawCanvas();
  		return;
		}
  }
  function eraseNearestDrawAction(p, tolPx){
    // tolPx: å½“ãŸã‚Šè¨±å®¹åŠå¾„(px)ã€‚æœªæŒ‡å®šãªã‚‰æ¶ˆã—ã‚´ãƒ ã‚µã‚¤ã‚º or 16px
    const baseTol = Math.max((state.eraserSize || 14), 16);
    const tol = Math.max(4, tolPx || baseTol);

    let bestd = Infinity, idx = -1;

    state.actions.forEach((a,i)=>{
      if (a.type !== 'draw') return;

      // ç·šã®å¤ªã•ã‚’å½“ãŸã‚Šåˆ¤å®šã«åŠ å‘³ï¼ˆå¤ªã„ç·šã»ã©å½“ãŸã‚Šã‚„ã™ã„ï¼‰
      const d = polylineDist(a.pts, p);
      const width = (a.width != null ? a.width : 2);
      const effD = d - width * 0.5; // å®Ÿè³ªè·é›¢ï¼ˆç·šå¹…ã®åŠåˆ†ã¶ã‚“è¿‘ãè¦‹ãªã™ï¼‰
      if (effD < bestd) { bestd = effD; idx = i; }
    });

    if (idx >= 0 && bestd <= tol) {
      state.actions.splice(idx, 1);
      return true;  // æ¶ˆã›ãŸ
    }
    return false;   // è§¦ã‚Œã¦ãªã„
  }

  function addErasePoint(p){
    if(state.dragging?.mode!=='erasePixel') return;
    state.dragging.eraser.pts.push([p.x,p.y]);
  }
  function finishEraseStroke(){
    const e = state.dragging.eraser;
    state.actions.push({type:'erase', radius:e.radius, pts:e.pts});
  }
  function polylineDist(pts, p){
    let bd=1e9; for(let i=1;i<pts.length;i++){ bd=Math.min(bd, pointSegDist(p,{x:pts[i-1][0],y:pts[i-1][1]},{x:pts[i][0],y:pts[i][1]})); }
    return bd;
  }
  function pointSegDist(p,a,b){
    const pr=projectPointToSeg(p,[a.x,a.y],[b.x,b.y]); return pr?pr.d:1e9;
  }

  
  function almostEq(a,b,eps=1e-2){ return Math.abs(a-b)<=eps; }
  function vsub(a,b){ return [a[0]-b[0], a[1]-b[1]]; }
  function vdot(a,b){ return a[0]*b[0] + a[1]*b[1]; }
  function vcross(a,b){ return a[0]*b[1] - a[1]*b[0]; }
  function vlen(a){ return Math.hypot(a[0],a[1]); }
  function isParallel(u,v,eps=1e-2){ return Math.abs(vcross(u,v))<=eps; }
  function isPerp(u,v,eps=1e-2){ return Math.abs(vdot(u,v))<=eps; }

  function autoType(points){
    const n=points.length;
    if(n===3) return 'tri';
    if(n===4){
      const p=points;
      const v0=vsub(p[1],p[0]);
      const v1=vsub(p[2],p[1]);
      const v2=vsub(p[3],p[2]);
      const v3=vsub(p[0],p[3]);
      const L=[vlen(v0), vlen(v1), vlen(v2), vlen(v3)];
      const allEqual = almostEq(L[0],L[1]) && almostEq(L[1],L[2]) && almostEq(L[2],L[3]);
      const para = isParallel(v0,v2) && isParallel(v1,v3);
      const rect = para && isPerp(v0,v1);
      const square = rect && allEqual;
      const rhombus = para && allEqual && !rect;
      const trapezoid = !para && (isParallel(v0,v2) || isParallel(v1,v3));
      if(square) return 'square';
      if(rect) return 'rect';
      if(rhombus) return 'rh';
      if(para) return 'para';
      if(trapezoid) return 'trap';
      return 'quad';
    }
    return `poly${n}`;
  }

  function labelByType(t){
    if(t==='tri') return 'ä¸‰è§’å½¢';
    if(t==='square') return 'æ­£æ–¹å½¢';
    if(t==='rect') return 'é•·æ–¹å½¢';
    if(t==='rh') return 'ã²ã—å½¢';
    if(t==='para') return 'å¹³è¡Œå››è¾ºå½¢';
    if(t==='trap') return 'å°å½¢';
    if(t==='quad') return 'å››è§’å½¢';
    if(t.startsWith('poly')){ const n=+t.slice(4); return `å¤šè§’å½¢ï¼ˆ${n}è§’å½¢ï¼‰`; }
    return 'å›³å½¢';
  }

  
  function lineIntersectsPolygon(a,b, poly){
    let cnt=0; for(let i=0;i<poly.length;i++){ const P=poly[i], Q=poly[(i+1)%poly.length]; const I=segI([a.x,a.y],[b.x,b.y],P,Q); if(I) cnt++; if(cnt>=2) return true; }
    return false;
  }
  function vertexIndexOnPolygon(poly, p, tolPx){ for(let i=0;i<poly.length;i++){ if(dist(poly[i][0],poly[i][1],p.x,p.y)<=tolPx) return i; } return -1; }
  function cleanupCycle(arr){ if(arr.length>2 && dist(arr[0][0],arr[0][1],arr[arr.length-1][0],arr[arr.length-1][1])<0.5) arr.pop(); }
  function splitByVertexIndices(poly, ia, ib){
    const n=poly.length; if(n<3) return null; const path1=[], path2=[];
    for(let k=0;k<=(ib-ia+n)%n;k++) path1.push( poly[(ia+k)%n] );
    for(let k=0;k<=(ia-ib+n)%n;k++) path2.push( poly[(ib+k)%n] );
    if(dist(poly[ia][0],poly[ia][1],poly[ib][0],poly[ib][1])>0.5){ path1.push(poly[ia]); path2.push(poly[ib]); }
    cleanupCycle(path1); cleanupCycle(path2);
    if(path1.length>=3 && path2.length>=3) return [path1,path2];
    return null;
  }
  function splitPolygonByLine(pts, a, b){
    const left=[], right=[]; const n=pts.length; if(n<3) return null; const EPS=1e-6;
    function isLeft(a,b,p){ return (b.x-a.x)*(p[1]-a.y) - (b.y-a.y)*(p[0]-a.x); }
    function pushUniq(arr, p){ const m=arr.length; if(!m || dist(arr[m-1][0],arr[m-1][1],p[0],p[1])>0.5) arr.push([p[0],p[1]]); }
    function lineIntersectSeg(a,b,P,Q){ return segI([a.x,a.y],[b.x,b.y],P,Q); }
    for(let i=0;i<n;i++){
      const P=pts[i], Q=pts[(i+1)%n];
      const sP=isLeft(a,b,P), sQ=isLeft(a,b,Q);
      if(sP>=-EPS) pushUniq(left, P); if(sP<=EPS) pushUniq(right, P);
      if((sP>EPS && sQ<-EPS) || (sP<-EPS && sQ>EPS)){
        const I=lineIntersectSeg(a,b,P,Q); if(I){ const Ipt=[I.x,I.y]; pushUniq(left,Ipt); pushUniq(right,Ipt); }
      }else if(Math.abs(sQ)<=EPS && i<n-1){ pushUniq(left,Q); pushUniq(right,Q); }
    }
    cleanupCycle(left); cleanupCycle(right);
    if(left.length>=3 && right.length>=3) return [left,right];
    return null;
  }
  function finishSplit(){
    const {a,b}=state.dragging;
    if(!a || !b){ if(state.splitPreview) state.splitPreview.remove(); updateSplitPin(null); setTool('edit'); render(); return; }
    for(let t=state.shapes.length-1; t>=0; t--){
      const sh=state.shapes[t];
      if(!lineIntersectsPolygon(a,b, sh.points)) continue;

      const viA=vertexIndexOnPolygon(sh.points, a, 1.0);
      const viB=vertexIndexOnPolygon(sh.points, b, 1.0);
      let res=null;
      if(viA!==-1 && viB!==-1 && viA!==viB) res=splitByVertexIndices(sh.points, viA, viB);
      if(!res) res=splitPolygonByLine(sh.points, a, b);
      if(res && res.length===2){const base={...sh};state.shapes.splice(t,1);const s1Pts=res[0], s2Pts=res[1];const s1Type=autoType(s1Pts);const s2Type=autoType(s2Pts);const basePts=base.points.slice(); const baseMeta=(base.vmeta||[]).slice();const s1={...base,id:uid(),type:s1Type,points:s1Pts}; s1.vmeta=__mapLabelsFromBase(s1Pts, basePts, baseMeta);const s2={...base,id:uid(),type:s2Type,points:s2Pts}; s2.vmeta=__mapLabelsFromBase(s2Pts, basePts, baseMeta);state.shapes.splice(t,0,s1,s2);}
    }
    if(state.splitPreview) state.splitPreview.remove();
	updateSplitPin(null);
	setTool(state.splitContinuous ? 'splitLine' : 'edit');
	render();
  }


  
  function pxToCm(px){ return px/pxPerCm; }
  function fmtLen(px){ return pxToCm(px).toFixed(2); }
  function updateBadges(){
    const sh=state.sel;
    if(!sh){
      ui.selType.textContent='â€”';
      ui.w.textContent='â€”'; ui.h.textContent='â€”'; ui.vh.textContent='â€”';
      ui.wLabel.textContent='å¹…'; ui.hLabel.textContent='é«˜ã•';
      return;
    }
    const t = autoType(sh.points);
    ui.selType.textContent = labelByType(t);
    const bb=bbox(sh.points);
    ui.w.textContent=fmtLen(bb.w); ui.h.textContent=fmtLen(bb.h);
    document.getElementById('u1').textContent='cm'; document.getElementById('u2').textContent='cm';
    ui.vh.textContent=`${sh.points.length}`;

    if(t==='tri' || t==='para'){ ui.wLabel.textContent='åº•è¾º'; ui.hLabel.textContent='é«˜ã•'; }
    else if(t==='rect' || t==='square'){ ui.wLabel.textContent='æ¨ª'; ui.hLabel.textContent='ãŸã¦'; }
    else { ui.wLabel.textContent='å¹…'; ui.hLabel.textContent='é«˜ã•'; }
  }

  function updateNoteHeaderPanel(){
    const nid = state.selNoteId;
    if(!nid){ ui.notePanel.style.display='none'; return; }
    const note = state.notes.find(n=>n.id===nid);
    if(!note){ ui.notePanel.style.display='none'; return; }
    ui.notePanel.style.display='flex';
    ui.noteHdrColor.value = note.color || 'yellow';
    ui.noteHdrSize.value  = note.font  || 'm';
  }
  ui.noteHdrColor.addEventListener('change', ()=>{
    const nid=state.selNoteId; if(!nid) return;
    const n=state.notes.find(x=>x.id===nid); if(!n) return;
    n.color=ui.noteHdrColor.value; pushHistory(); render();
  });
  ui.noteHdrSize.addEventListener('change', ()=>{
    const nid=state.selNoteId; if(!nid) return;
    const n=state.notes.find(x=>x.id===nid); if(!n) return;
    n.font=ui.noteHdrSize.value; pushHistory(); render();
  });

  
  function snapshot(){
    return JSON.stringify({
      shapes: state.shapes,
      notes: state.notes,
      actions: state.actions
    });
  }
  function restore(json){
    const s=JSON.parse(json);
    state.shapes = s.shapes || [];
    state.notes  = s.notes  || [];
    state.actions = s.actions || [];
    drawGrid(); render();
  }
  function pushHistory(){ state.history.push(snapshot()); state.future=[]; }
  ui.undo.addEventListener('click', ()=>{ if(!state.history.length) return; const cur=snapshot(); const prev=state.history.pop(); state.future.push(cur); restore(prev); });
  ui.redo.addEventListener('click', ()=>{ if(!state.future.length) return; const cur=snapshot(); const next=state.future.pop(); state.history.push(cur); restore(next); });

  
  ui.exportBtn.addEventListener('click', ()=>{
    const data=snapshot();
    const blob=new Blob([data],{type:'application/json'});
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='board.json'; a.click(); URL.revokeObjectURL(a.href);
  });
  ui.importInput.addEventListener('change', async (e)=>{
    const f=e.target.files[0]; if(!f) return; const tx=await f.text(); restore(tx); pushHistory();
  });
  ui.resetBtn.addEventListener('click', ()=>{ location.reload(); });

  
  ui.toolbar.addEventListener('click', (e)=>{
    const b=e.target.closest('button'); if(!b) return;
    const add=b.getAttribute('data-add'); const tool=b.getAttribute('data-tool');
    [...ui.toolbar.querySelectorAll('button')].forEach(x=>x.classList.remove('active'));
    b.classList.add('active');
    if(add){ addShape(add); return; }
    if(tool){ setTool(tool); render(); return; }
  });
  ui.gridSize.addEventListener('change', ()=>{
    const cm=parseInt(ui.gridSize.value,10)||2.5; state.gridPx=pxPerCm*cm; drawGrid(); render(); redrawCursorOverlay();
  });
  ui.splitGridSnap.addEventListener('change', ()=>{
	  state.splitGridSnap = ui.splitGridSnap.checked;
	  if (state.splitGridSnap) setTool('splitLine');
  });

  ui.vertexEdit.addEventListener('change', ()=>{ state.vertexEdit=ui.vertexEdit.checked; render(); });
  ui.splitContinuous?.addEventListener('change', ()=>{state.splitContinuous = !!ui.splitContinuous.checked;});
  ui.color.addEventListener('input', ()=>{ if(state.sel){ state.sel.fill=ui.color.value; state.sel.stroke=ui.color.value; state.sel.userColored = true; pushHistory(); render(); } });
  ui.lockSize.addEventListener('change', ()=> state.lockSize=ui.lockSize.checked );
  ui.dup.addEventListener('click', ()=>{ if(!state.sel) return; const c=JSON.parse(JSON.stringify(state.sel)); c.id=uid(); c.points=c.points.map(p=>[p[0]+20,p[1]+20]); state.shapes.push(c); selectShape(c); pushHistory(); });
  ui.front.addEventListener('click', ()=>{ if(!state.sel) return; const i=state.shapes.findIndex(s=>s.id===state.sel.id); state.shapes.push(...state.shapes.splice(i,1)); pushHistory(); render(); });
  ui.back.addEventListener('click', ()=>{ if(!state.sel) return; const i=state.shapes.findIndex(s=>s.id===state.sel.id); state.shapes.unshift(...state.shapes.splice(i,1)); pushHistory(); render(); });
  ui.flipH.addEventListener('click', ()=> flipSel(true,false));
  ui.flipV.addEventListener('click', ()=> flipSel(false,true));
  ui.deleteShape.addEventListener('click', ()=>{
    if(state.sel){ state.shapes=state.shapes.filter(s=>s.id!==state.sel.id); state.sel=null; pushHistory(); render(); }
  });
	
	
	ui.penColor.addEventListener('change', ()=> {
  	state.penColor = ui.penColor.value;
  	if (!suppressPenAutoSelect) setTool('draw'); 
  	render();
	});

	
	ui.penThickness.addEventListener('change', ()=>{
  	state.penThickness = parseFloat(ui.penThickness.value) || 1.5;
  	setTool('draw');   
  	render();
	});

	
	ui.penStraight.addEventListener('change', ()=>{
  	state.penStraight = ui.penStraight.checked;
  	if (!state.penStraight) state.__dragStart = null; 
  	setTool('draw');   
  	redrawCursorOverlay();
  	const btn = document.getElementById('btnPenToggle');
  	if (btn) btn.textContent = penLabelFrom(state.penThickness);
	});

	
  ui.eraserMode.addEventListener('change', ()=>{
  	state.eraserMode = ui.eraserMode.value;
  	updateEraserSizeVisibility();
  	setTool('erase');
  	redrawCursorOverlay();
	});
  
	eraserSizeSel.addEventListener('change', ()=>{
  	state.eraserSize = parseInt(eraserSizeSel.value,10) || 14;
  	setTool('erase');              
  	redrawCursorOverlay();
  	const btn = document.getElementById('btnEraserCycle');
  	if (btn) btn.textContent = eraserLabelFrom(state.eraserSize);
	});
	function updateEraserSizeVisibility(){
  // ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ã¯é‹ç”¨ä¸Šã€å¸¸ã«éš ã™
  const sizeSel = document.getElementById('eraserSize');
  if (!sizeSel) return;
  sizeSel.style.display = 'none';
	}
  function rotateSel(deg){ if(!state.sel) return; const c=centroid(state.sel.points); const r=deg*Math.PI/180;
    state.sel.points=state.sel.points.map(([x,y])=>{const dx=x-c.x, dy=y-c.y; return [c.x+dx*Math.cos(r)-dy*Math.sin(r), c.y+dx*Math.sin(r)+dy*Math.cos(r)];});
    pushHistory(); render();
  }
  function flipSel(h,v){ if(!state.sel) return; const c=centroid(state.sel.points);
    state.sel.points=state.sel.points.map(([x,y])=>[ h?(2*c.x-x):x, v?(2*c.y-y):y ]);
    pushHistory(); render();
  }

  document.addEventListener('keydown', (e)=>{
    if(e.key==='Delete' && !document.activeElement.isContentEditable){
      if(state.sel){ state.shapes=state.shapes.filter(s=>s.id!==state.sel.id); state.sel=null; pushHistory(); render(); }
    }
  });

  
  const LIGHT_PENS = [
    { value: '#1f2937', label: 'é»’' },
    { value: '#ef4444', label: 'èµ¤' },
    { value: '#2563eb', label: 'é’' },
    { value: '#16a34a', label: 'ç·‘' },
  ];
  const DARK_PENS = [
    { value: '#ffffff', label: 'ç™½' },
    { value: '#ff6b00', label: 'ã‚ªãƒ¬ãƒ³ã‚¸' },
    { value: '#33ddff', label: 'æ°´è‰²' },
    { value: '#a8ff00', label: 'é»„ç·‘' },
  ];
  function showPenOptionsForTheme(theme){
  	
  	const prev = (state.penColor || ui.penColor.value || '').toLowerCase();

  	
  	const mapped = (theme === 'dark'
    	? (DARK_PEN_MAP[prev]  || prev)
    	: (LIGHT_PEN_MAP[prev] || prev)
  	).toLowerCase();

  	
  	while (ui.penColor.firstChild) ui.penColor.removeChild(ui.penColor.firstChild);
  	const list = (theme === 'dark') ? DARK_PENS : LIGHT_PENS;
  	for (const {value, label} of list){
    	const opt = document.createElement('option');
    	opt.value = value;
    	opt.textContent = label;
    	ui.penColor.appendChild(opt);
  	}

  	
  	const hasMapped = list.some(x => x.value.toLowerCase() === mapped);
  	ui.penColor.value = hasMapped ? mapped : list[0].value;

  	
  	state.penColor = ui.penColor.value;
	}
  
	const DARK_PEN_MAP = {
  	'#1f2937':'#ffffff', 
  	'#ef4444':'#ff6b00', 
  	'#2563eb':'#33ddff', 
  	'#16a34a':'#a8ff00'  
	};
	const LIGHT_PEN_MAP = {
  	'#ffffff':'#1f2937', 
  	'#ff6b00':'#ef4444', 
  	'#33ddff':'#2563eb', 
  	'#a8ff00':'#16a34a'  
	};

	function recolorDrawActionsForTheme(theme){
  	const map = (theme==='dark') ? DARK_PEN_MAP : LIGHT_PEN_MAP;
  	for(const act of state.actions){
    	if (act.type !== 'draw') continue;
    	const c = (act.color||'').toLowerCase();
    	if (map[c]) act.color = map[c];
  	}
	}

	function remapCurrentPenColor(theme){
  	const map = (theme==='dark') ? DARK_PEN_MAP : LIGHT_PEN_MAP;

  	
  	const cur = (state.penColor||'').toLowerCase();
  	if (map[cur]) state.penColor = map[cur];

  	
  	const visible = Array.from(ui.penColor.options).filter(o=>!o.hidden);
  	const hasVisibleSame = visible.some(o => o.value.toLowerCase() === state.penColor.toLowerCase());
  	ui.penColor.value = hasVisibleSame ? state.penColor : (visible[0]?.value || state.penColor);

  	
  	state.penColor = ui.penColor.value;
	}

	function applyTheme(theme){
  	
  	document.documentElement.setAttribute('data-theme', theme);
  	ui.themeToggle.textContent = (theme === 'dark') ? 'â˜€ï¸' : 'ğŸŒ™';
  	localStorage.setItem('board-theme', theme);
    
	 	
	  suppressPenAutoSelect = true;
  	
  	showPenOptionsForTheme(theme);

  	
  	remapCurrentPenColor(theme);
		suppressPenAutoSelect = false;
    
  	
  	recolorDrawActionsForTheme(theme);

  	
		const newColor = THEME_SHAPE_COLOR[theme];
		for(const sh of state.shapes){
  		if(!sh.userColored){
    		sh.fill = newColor;
    		sh.stroke = newColor;
  		}
		}
		
		ui.color.value = newColor;
		if (state.sel){ state.sel.fill = newColor; state.sel.stroke = newColor; }
    
  	
  	drawGrid();
  	render();
  	redrawCanvas();
  	redrawCursorOverlay();

  	
  	ui.penColor.dispatchEvent(new Event('change', {bubbles:false}));
	}

  ui.themeToggle.addEventListener('click', ()=>{
    const cur = document.documentElement.getAttribute('data-theme') || 'light';
    applyTheme(cur==='light' ? 'dark' : 'light');
  });
  (function initTheme(){
    const saved = localStorage.getItem('board-theme');
    if(saved){ applyTheme(saved); }
    else {
      const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      applyTheme(prefersDark ? 'dark' : 'light');
    }
  })();

  
  ui.asideTab.addEventListener('click', ()=>{
  	const collapsed = document.body.classList.toggle('aside-collapsed');
  	scheduleRelayout();
  	refreshSidebarTabIcons();
    drawGrid();
  	render();
  	redrawCanvas();
  	redrawCursorOverlay();
	});

  
  function redrawCursorOverlay(){
  	const W=cursorCanvas.width/state.dpr, H=cursorCanvas.height/state.dpr;
  	cctx.clearRect(0,0,W,H);
  	const p = state.pointerPos;
    
    
  	if (state.tool === 'draw' && state.penStraight && state.lineAnchor) {
    	
    	const s = snapPointWithProjection(p.x, p.y) || p;

    	cctx.save();
    	
    	cctx.beginPath();
    	cctx.arc(state.lineAnchor.x, state.lineAnchor.y, 3, 0, Math.PI*2);
    	cctx.fillStyle = 'rgba(239,68,68,0.9)'; 
    	cctx.fill();

    	
    	cctx.beginPath();
    	cctx.moveTo(state.lineAnchor.x, state.lineAnchor.y);
    	cctx.lineTo(s.x, s.y);
    	cctx.lineWidth = state.penThickness || 1.5;
    	cctx.setLineDash([6,4]);
    	cctx.strokeStyle = 'rgba(239,68,68,0.9)';
    	cctx.lineCap = 'round';
    	cctx.lineJoin = 'round';
    	cctx.stroke();
    	cctx.restore();
  	}

  	
  	if(state.tool==='erase'){
    	cctx.save();
    	cctx.beginPath();
    	const r = (state.eraserSize || 14)/2;
    	cctx.arc(p.x, p.y, r, 0, Math.PI*2);
    	cctx.fillStyle='rgba(180,180,180,0.2)';
    	cctx.strokeStyle='rgba(120,120,120,0.6)';
    	cctx.lineWidth=1;
    	cctx.fill(); cctx.stroke();
    	cctx.restore();
    	return; 
  	}

  	
  	if (state.tool==='draw' && state.penStraight && state.lineAnchor){
    	
    	const s = snapPointWithProjection(p.x, p.y) || p;

    	cctx.save();
    	cctx.beginPath();
    	cctx.moveTo(state.lineAnchor.x, state.lineAnchor.y);
    	cctx.lineTo(s.x, s.y);
    	cctx.lineWidth = state.penThickness || 1.5;
    	cctx.lineCap = 'round';
    	cctx.lineJoin = 'round';
    	cctx.strokeStyle = state.penColor || '#1f2937';
    	cctx.globalAlpha = 0.9; 
    	cctx.stroke();
    	cctx.restore();
  	}
	}

  
  function boot(){
    
		document.body.classList.add('asideB-collapsed');
    
    (function(){
      if (window.__iosTouchPatched) return;
      window.__iosTouchPatched = true;
      const inNote = (el)=> !!(el && (el.classList?.contains('note') || el.closest?.('.note')));

      document.addEventListener('dblclick', (e)=>{ if(!inNote(e.target)) e.preventDefault(); }, {capture:true, passive:false});
      let lastTouchEnd = 0;
      document.addEventListener('touchend', (e)=>{
        if(inNote(e.target)) return;
        const now = Date.now();
        if (now - lastTouchEnd <= 350) e.preventDefault();
        lastTouchEnd = now;
      }, {capture:true, passive:false});
      document.addEventListener('gesturestart', (e)=>{ if(!inNote(e.target)) e.preventDefault(); }, {capture:true, passive:false});
      document.addEventListener('contextmenu', (e)=>{ if(!inNote(e.target)) e.preventDefault(); }, {capture:true, passive:false});
      document.addEventListener('selectstart', (e)=>{ if(!inNote(e.target)) e.preventDefault(); }, {capture:true, passive:false});
    })();

    
    try{
      if (window.matchMedia && window.matchMedia('(pointer:coarse)').matches) {
        state.snapTol = Math.max(state.snapTol, 20);
      }
    }catch(_){}

    
    window.addEventListener('resize', onViewportChange, {passive:true});
    window.addEventListener('orientationchange', onViewportChange, {passive:true});
    try{
      if (window.visualViewport) {
        visualViewport.addEventListener('resize', onViewportChange, {passive:true});
        visualViewport.addEventListener('scroll', onViewportChange, {passive:true});
      }
    }catch(_){}

    ensureLayout();
    ui.gridSize?.dispatchEvent(new Event('change'));
    // === èµ·å‹•æ™‚ã®ã‚°ãƒªãƒƒãƒ‰ã‚’ã‚»ãƒ¬ã‚¯ãƒˆå€¤ã§ç¢ºå®š ===
	try {
  	const initCm = parseInt(ui.gridSize?.value, 10) || 2.5;
  	state.gridPx = pxPerCm * initCm;
	} catch(_) {
  	state.gridPx = pxPerCm * 2.5;
	}
    const tick=()=>{
      const r=board.getBoundingClientRect();
      if(r.width<2 || r.height<2){ requestAnimationFrame(tick); return; }
      drawGrid(); render(); redrawCursorOverlay();
      const wrap=document.querySelector('.board-wrap');
      if(window.ResizeObserver && wrap){
        const ro=new ResizeObserver(()=>{ ensureLayout(); drawGrid(); render(); redrawCursorOverlay(); });
        ro.observe(wrap);
      }
    };
    requestAnimationFrame(tick);
    const showVerticesEl=document.getElementById('showVertices');
      if(showVerticesEl){
      document.body.classList.toggle('show-vertices',showVerticesEl.checked);
      showVerticesEl.addEventListener('change',e=>{
      document.body.classList.toggle('show-vertices',e.target.checked);
      });
    }
  }
  refreshSidebarTabIcons();                
	requestAnimationFrame(refreshSidebarTabIcons); 
	bindMainTransitionRelayout();            
  updateEraserSizeVisibility();
  window.addEventListener('load', boot);
  window.addEventListener('load', ()=> setTool('edit'));
  
  function dataURLtoFile(dataURL, filename){
  	const arr = dataURL.split(',');
  	const mime = arr[0].match(/:(.*?);/)[1] || 'image/png';
  	const bstr = atob(arr[1]);
  	let n = bstr.length;
  	const u8 = new Uint8Array(n);
  	while(n--) u8[n] = bstr.charCodeAt(n);
  	return new File([u8], filename, { type: mime });
	}

	async function shareAllSnaps(){
    alert('ã€Œã€œæšã®ç”»åƒã‚’ä¿å­˜ã€ã‚’æŠ¼ãã†ï¼');
  	
  	if (state.snaps.length === 0){
    	alert('å…±æœ‰ã§ãã‚‹ã‚¹ãƒŠãƒƒãƒ—ãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
    	return;
  	}
  	if (state.snaps.length > 7){
    	alert('å…±æœ‰ã§ãã‚‹ã®ã¯æœ€å¤§7æšã¾ã§ã§ã™ã€‚');
    	return;
  	}

  	
  	const files = state.snaps.map((s, i) =>
    	dataURLtoFile(s.dataURL, `hippoly_${String(i+1).padStart(2,'0')}.png`)
  	);

  	
  	let canShareFiles = false;
		try {
  		canShareFiles = !!(navigator.canShare && navigator.canShare({ files }));
		} catch(_) {
  		canShareFiles = false;
		}

  	if (canShareFiles){
    	
    	uiB.saveAll.disabled = true;
    	try{
      	await navigator.share({
        	files,
        	title: 'Hippoly ã‚¹ãƒŠãƒƒãƒ—',
        	text: `${files.length}æšã®ç”»åƒ`
      	});
      	
    	} catch(err) {
  			console.warn('share canceled or failed:', err);
  			
  			if (err && err.name === 'AbortError') return;
  			
  			if (err && err.message && /share/i.test(err.message)) return;
  			
			} finally {
      	uiB.saveAll.disabled = false;
    	}
  	}else{
    	
    	await saveAllSnapsFallback();
  	}
	}

	
	async function saveAllSnapsFallback(){
  	if (state.snaps.length === 0){
    	alert('ä¿å­˜ã§ãã‚‹ã‚¹ãƒŠãƒƒãƒ—ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚');
    	return;
  	}
  	if (state.snaps.length > 7){
    	alert('ä¿å­˜ã§ãã‚‹ã®ã¯æœ€å¤§7æšã¾ã§ã§ã™ã€‚');
    	return;
  	}
  	uiB.saveAll.disabled = true;
  	try{
    	for(let i=0;i<state.snaps.length;i++){
      	const a = document.createElement('a');
      	a.href = state.snaps[i].dataURL;
      	a.download = `hippoly_${String(i+1).padStart(2,'0')}.png`;
      	document.body.appendChild(a);
      	a.click();
      	a.remove();
      	await new Promise(r=>setTimeout(r, 120));
    	}
  	}finally{
    	uiB.saveAll.disabled = false;
  	}
	}
  
function canStartDrawing(e){
  if(state.drawingPointerId!=null) return false;
  state.drawingPointerId = e.pointerId;
  return true;
}
function endDrawingIfMatches(e){
  if(state.drawingPointerId===e.pointerId) state.drawingPointerId=null;
}


(function(){
  const tab=document.getElementById('headerTab');
  if(tab){
    tab.addEventListener('click', ()=>{
      document.body.classList.toggle('header-tools-collapsed');
    });
  }
})();


// ========== initial draw queue (waits for stable layout) ==========
function __queueInitialDraw(){
  let tries = 0;
  const pump = ()=>{
    tries++;
    try{ ensureLayout(); }catch(_){}
    try{
      const r = (typeof board!=='undefined' && board && board.getBoundingClientRect) ? board.getBoundingClientRect() : {width:0,height:0};
      if(!r || r.width < 2 || r.height < 2){
        if(tries < 60){ requestAnimationFrame(pump); }
        return;
      }
      drawGrid();
      render();
      redrawCanvas();
      redrawCursorOverlay();
    }catch(_){}
  };
  requestAnimationFrame(()=>requestAnimationFrame(pump));
}
try{ document.addEventListener('DOMContentLoaded', ()=>{ __queueInitialDraw(); }, {once:true}); }catch(_){}
try{ window.addEventListener('load', ()=>{ __queueInitialDraw(); }, {once:true}); }catch(_){}


// ==== header height compute + redraw ====
function __measureHeaderHeight(){
  try{
    const h = document.querySelector('header');
    const rect = h ? h.getBoundingClientRect() : null;
    const px = rect ? Math.max(0, Math.floor(rect.height)) : 0;
    if(px>0){
      document.documentElement.style.setProperty('--header-h', px + 'px');
    }
  }catch(_){}
}
function __kickRedrawAfterHeaderMeasure(){
  try{ __measureHeaderHeight(); }catch(_){}
  try{ ensureLayout(); }catch(_){}
  try{ drawGrid(); }catch(_){}
  try{ render(); }catch(_){}
  try{ redrawCanvas(); }catch(_){}
  try{ redrawCursorOverlay(); }catch(_){}
}
// measure on ready, after fonts, and on header mutations
document.addEventListener('DOMContentLoaded', ()=>{
  __kickRedrawAfterHeaderMeasure();
  try{ if(document.fonts && document.fonts.ready){ document.fonts.ready.then(()=>__kickRedrawAfterHeaderMeasure()); } }catch(_){}
}, {once:true});
window.addEventListener('load', ()=>{ __kickRedrawAfterHeaderMeasure(); }, {once:true});
(function(){
  const h=document.querySelector('header');
  if(!h || !('MutationObserver' in window)) return;
  const mo=new MutationObserver(()=>{ __kickRedrawAfterHeaderMeasure(); });
  mo.observe(h, {attributes:true, childList:true, subtree:true});
})();


// heuristic: mark header-fixed if computed position is fixed or sticky
(function(){
  try{
    const h=document.querySelector('header');
    if(!h) return;
    const pos = getComputedStyle(h).position;
    if(pos === 'fixed'){
      document.body.classList.add('header-fixed');
    }else{
      document.body.classList.remove('header-fixed');
    }
  }catch(_){}
})();

// === straight-line snapping helpers ===
const SNAP_VTX = 16;   // é ‚ç‚¹ã‚¹ãƒŠãƒƒãƒ—åŠå¾„(px)
const SNAP_EDGE = 12;  // è¾ºã‚¹ãƒŠãƒƒãƒ—è·é›¢(px)

function dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }
function projOnSeg(p, a, b){
  const vx=b.x-a.x, vy=b.y-a.y;
  const wx=p.x-a.x, wy=p.y-a.y;
  const vv = vx*vx+vy*vy || 1;
  let t = (vx*wx+vy*wy)/vv;
  if(t<0) t=0; else if(t>1) t=1;
  return { x: a.x+vx*t, y: a.y+vy*t, t };
}
function allVertices(){
  const out=[];
  for(const sh of (state.shapes||[])){
    if(!sh?.points) continue;
    for(const p of sh.points) out.push({x:p[0], y:p[1], shape:sh});
  }
  return out;
}
function allEdges(){
  const out=[];
  for(const sh of (state.shapes||[])){
    const pts = sh.points||[];
    for(let i=0;i<pts.length;i++){
      const a={x:pts[i][0], y:pts[i][1]}, b={x:pts[(i+1)%pts.length][0], y:pts[(i+1)%pts.length][1]};
      out.push({a,b,shape:sh});
    }
  }
  return out;
}
function snapStartPoint(p){
  // é ‚ç‚¹å„ªå…ˆ
  let bestV=null, bestD2=Infinity;
  for(const v of allVertices()){
    const d2=dist2(p,v);
    if(d2<bestD2 && d2<=SNAP_VTX*SNAP_VTX){ bestD2=d2; bestV=v; }
  }
  if(bestV) return { mode:'vertex', start:{x:bestV.x,y:bestV.y} };

  // æ¬¡ã«è¾º
  let bestE=null, bestPt=null, bestAbs=Infinity;
  for(const e of allEdges()){
    const q=projOnSeg(p,e.a,e.b);
    const d=Math.hypot(p.x-q.x,p.y-q.y);
    if(d<bestAbs && d<=SNAP_EDGE){ bestAbs=d; bestE=e; bestPt=q; }
  }
  if(bestE) return { mode:'edge', start:bestPt, edge:bestE };

  // ä½•ã‚‚ãªã‘ã‚Œã°ãƒ•ãƒªãƒ¼
  return { mode:'free', start:{x:p.x,y:p.y} };
}
function constrainOnEdge(cur, edge){
  return projOnSeg(cur, edge.a, edge.b);
}

// === ãƒ˜ãƒƒãƒ€å³ç«¯ã‚¿ãƒ–ï¼šä¿å­˜/èª­ã¿è¾¼ã¿ã‚’ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‹ã‚‰ç™ºç« ===
(function(){
  const tab  = document.getElementById('headerTab');
  const menu = document.getElementById('headerMenu');
  if(!tab || !menu) return;

  // æ—¢å­˜ãƒãƒ³ãƒ‰ãƒ©ã‚’å°Šé‡ï¼šexport/import è¦ç´ ãŒã‚ã‚Œã° click å§”è­²
  function doSave(){
    const btn = document.getElementById('export');
    if(btn){ btn.click(); return; }
    if(typeof saveAllSnaps==='function'){ saveAllSnaps(); return; }
    console.warn('ä¿å­˜å…ˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
  }
  function doLoad(){
    const inp = document.getElementById('import');
    if(inp){ inp.click(); return; }
    if(typeof loadFromFile==='function'){ loadFromFile(); return; }
    console.warn('èª­ã¿è¾¼ã¿å…ˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
  }

  tab.addEventListener('click', (e)=>{
    e.stopPropagation();
    menu.classList.toggle('open');
  });

  menu.addEventListener('click', (e)=>{
    const act = e.target && e.target.getAttribute && e.target.getAttribute('data-act');
    if(act==='save'){ doSave(); menu.classList.remove('open'); }
    if(act==='load'){ doLoad(); menu.classList.remove('open'); }
  });

  // å¤–å´ã‚¯ãƒªãƒƒã‚¯ã§ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’é–‰ã˜ã‚‹
  document.addEventListener('click', ()=>{
    if(menu.classList.contains('open')) menu.classList.remove('open');
  });
})();

// === ã‚«ãƒƒãƒˆè¨­å®š ===
(function(){
  const chk = document.getElementById('cutAlongEdge');
  if(!chk) return;
  state.cutAlongEdge = !!chk.checked;
  chk.addEventListener('change', ()=>{ state.cutAlongEdge = !!chk.checked; });
})();
	  // ==== ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆè¨­å®š ====
document.addEventListener('keydown', (e)=>{
  const mod = e.ctrlKey || e.metaKey; // Ctrl or âŒ˜ ã©ã¡ã‚‰ã§ã‚‚OK

  // ã‚¹ãƒŠãƒƒãƒ—ï¼ˆğŸ“·ï¼‰
  if (mod && e.key.toLowerCase() === 's') {
    e.preventDefault();
    const shotBtn = document.getElementById('shot');
    if (shotBtn) shotBtn.click();
  }

  // Undoï¼ˆæˆ»ã‚‹ï¼‰
  if (mod && !e.shiftKey && e.key.toLowerCase() === 'z') {
    e.preventDefault();
    if (typeof undo === 'function') undo();
  }

  // Redoï¼ˆé€²ã‚€ï¼‰
  if (mod && e.shiftKey && e.key.toLowerCase() === 'z') {
    e.preventDefault();
    if (typeof redo === 'function') redo();
  }

  // ä¾‹ï¼šãƒ„ãƒ¼ãƒ«åˆ‡æ›¿ï¼ˆå¿…è¦ãªã‚‰ï¼‰
  if (e.key.toLowerCase() === 'p') setTool('draw');   // ãƒšãƒ³
  if (e.key.toLowerCase() === 'e') setTool('erase');  // æ¶ˆã—ã‚´ãƒ 
  if (e.key.toLowerCase() === 'm') setTool('edit');   // ç§»å‹•
});
	  

/* === Vertex Labels Helpers (CW from top-left; outside placement) === */
function __assignLabels(sh){
  const n = (sh.points||[]).length;
  sh.vmeta = new Array(n).fill(null);
  if(n===0) return;
  // centroid
  let cx=0, cy=0;
  for(const [x,y] of sh.points){ cx+=x; cy+=y; }
  cx/=n; cy/=n;
  // CW order by angle around centroid
  const idxs = [...sh.points.keys()];
  idxs.sort((i,j)=>{
    const ai = Math.atan2(sh.points[i][1]-cy, sh.points[i][0]-cx);
    const aj = Math.atan2(sh.points[j][1]-cy, sh.points[j][0]-cx);
    return aj - ai; // CW
  });
  // top-left vertex index
  let tl = 0, bestY = Infinity, bestX = Infinity;
  for(let i=0;i<n;i++){
    const [x,y]=sh.points[i];
    if(y < bestY - 1e-6 || (Math.abs(y - bestY) <= 1e-6 && x < bestX)){ bestY=y; bestX=x; tl=i; }
  }
  // rotate order to start at top-left
  const startPos = idxs.indexOf(tl);
  const order = startPos>=0 ? idxs.slice(startPos).concat(idxs.slice(0,startPos)) : idxs;
  const letters=['A','B','C','D'];
  for(let k=0;k<Math.min(4, order.length);k++){ sh.vmeta[order[k]] = letters[k]; }
}
function __ensureLabelsLayer(){
  if(!document.getElementById('labelsLayer')){
    const g=document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('id','labelsLayer'); board.appendChild(g);
  }
}
function __renderLabels(){
  __ensureLabelsLayer();
  const layer=document.getElementById('labelsLayer'); if(!layer) return;
  layer.innerHTML='';
  const font=Math.max(10,Math.round(0.26*state.gridPx));
  for(const sh of state.shapes){
    if(!sh?.vmeta || !sh?.points) continue;
    const n=sh.points.length; if(!n) continue;
    // centroid
    let cx=0, cy=0; for(const [x,y] of sh.points){ cx+=x; cy+=y; } cx/=n; cy/=n;
    for(let i=0;i<n;i++){
      const label=sh.vmeta[i]; if(!label) continue;
      const [x,y]=sh.points[i];
      // vector outward
      let dx=x-cx, dy=y-cy; const L=Math.hypot(dx,dy)||1; dx/=L; dy/=L;
      const pad=Math.max(8, Math.round(0.28*state.gridPx)); // scale with grid
      const tx=x+dx*pad, ty=y+dy*pad;
      const t=document.createElementNS('http://www.w3.org/2000/svg','text');
      t.setAttribute('x', String(tx)); t.setAttribute('y', String(ty));
      t.setAttribute('fill', '#111'); t.setAttribute('font-size', String(font));
      t.setAttribute('font-family','system-ui,-apple-system,Segoe UI,Roboto,Meiryo,sans-serif');
      t.textContent=label; layer.appendChild(t);
    }
  }
}
function __mapLabelsFromBase(newPts, basePts, baseMeta){
  const vm=new Array(newPts.length).fill(null);
  for(let i=0;i<newPts.length;i++){
    const [x,y]=newPts[i];
    for(let j=0;j<basePts.length;j++){
      const bp=basePts[j];
      if(Math.hypot(bp[0]-x,bp[1]-y)<=0.75){ vm[i]=baseMeta[j]||null; break; }
    }
  }
  return vm;
}
</script>
 </body>
</html>
