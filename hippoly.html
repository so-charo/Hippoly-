html<!DOCTYPE html>
<html lang="ja" data-theme="light">
<head>
  <meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Hippoly!</title>
  <link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="icon192.png">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<script>
  if ("serviceWorker" in navigator) {
    navigator.serviceWorker.register("./sw.js");
  }
</script>
  <style>
    /* ========== ãƒ†ãƒ¼ãƒï¼ˆãƒ©ã‚¤ãƒˆ/ãƒ€ãƒ¼ã‚¯ï¼‰ ========== */
		/* â˜… iPad é•·æŠ¼ã—ã®é¸æŠãƒ»ã‚³ãƒ¼ãƒ«ã‚¢ã‚¦ãƒˆã‚’å…¨è¦ç´ ã§æŠ‘æ­¢ã€‚ä»˜ç®‹ã¯ä¾‹å¤–ã§è§£é™¤ */
	* {
		-webkit-user-select: none;
		user-select: none;
    -webkit-touch-callout: none;
    -webkit-tap-highlight-color: transparent;
  }

		/* ä»˜ç®‹å†…ã¯é¸æŠãƒ»ã‚³ãƒ”ãƒ¼ã‚’è¨±å¯ */
		.note, .note * {
      -webkit-user-select: text !important;
      user-select: text !important;
      -webkit-touch-callout: default !important;
    }
    
    /* â˜… UIè¦ç´ ã¯ manipulation ã§ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ã‚ºãƒ¼ãƒ ã‚’æŠ‘åˆ¶ */
		button, label, select, input {
      touch-action: manipulation;
    }

		/* â˜… ä»˜ç®‹å†…ã¯å¾“æ¥ã©ãŠã‚Šé¸æŠå¯ãƒ»ã‚³ãƒ”ãƒ¼å¯ */
		.note, .note * {
  		-webkit-user-select: text;
  		user-select: text;
  		-webkit-touch-callout: default;
		}
    
    :root {
      /* åŸºæœ¬ */
      --page-bg:#f7fafc;
      --text:#111827;
      --panel-bg:#ffffff;
      --panel-shadow:0 10px 30px rgba(0,0,0,.06);
      --accent:#2563eb;
      --soft:#e5e7eb;

      /* ãƒœã‚¿ãƒ³ */
      --btn-bg:#ffffff;
      --btn-border:#e5e7eb;
      --btn-active:#dbeafe;
      --btn-hover-shadow:0 1px 3px rgba(0,0,0,.06);
      --btn-focus:#93c5fd;

      /* æ–¹çœ¼ */
      --grid-cm:37.7952755906; /* 96dpiå‰æ 1cm â‰’ 37.795px */
      --grid-stroke:#bfdbfe;   /* è–„æ°´è‰² */
      --grid-pt:1.0;           /* 1px */

      /* ä»˜ç®‹è‰² */
      --note-yellow:#fffbe6;
      --note-blue:#e6f3ff;
      --note-pink:#ffeaf1;

      /* ãƒãƒƒã‚¸/ãƒ˜ãƒ«ãƒ— */
      --badge-bg:#eef2ff;
      --badge-text:#1e3a8a;
      --hint:#6b7280;

      /* ã‚µã‚¤ãƒ‰ãƒãƒ¼ */
      --aside-width:360px;       /* iPadç¸¦ã§ã‚‚å…¨ãƒ„ãƒ¼ãƒ«è¡¨ç¤ºã§ãã‚‹å¹…ã«èª¿æ•´ */
      --aside-collapsed:24px;    /* çªèµ·ã ã‘æ®‹ã™å¹… */
    }

    /* ãƒ€ãƒ¼ã‚¯ãƒ†ãƒ¼ãƒ */
    [data-theme="dark"] {
      --page-bg:#0f172a;
      --text:#e5e7eb;
      --panel-bg:#111827;
      --panel-shadow:0 10px 30px rgba(0,0,0,.35);

      --btn-bg:#1f2937;
      --btn-border:#334155;
      --btn-active:#1d4ed8;
      --btn-hover-shadow:0 1px 3px rgba(255,255,255,.06);
      --btn-focus:#60a5fa;

      --grid-stroke:#334155;
      --grid-pt:1.0;

      --note-yellow:#5b5b3a;
      --note-blue:#334e68;
      --note-pink:#6e3948;

      --badge-bg:#1f2937;
      --badge-border:#374151;
      --badge-text:#dbeafe;
      --hint:#94a3b8;
    }

    html,body{height:100%;}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN",Meiryo,sans-serif;
      background:var(--page-bg); color:var(--text);
      display:grid; grid-template-rows:auto 1fr;
      overflow:hidden; /* ãƒšãƒ¼ã‚¸å…¨ä½“ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç„¡åŠ¹åŒ– */
    }
    header{
      background:var(--panel-bg); color:var(--text);
      padding:10px 12px; box-shadow:0 2px 10px rgba(0,0,0,.06);
      position:sticky; top:0; z-index:10;
    }
    header .row{display:flex; flex-wrap:wrap; gap:10px; align-items:center;}
    header .title{font-weight:700;}
    select, input[type="color"], button, label.toggle{
      border:1px solid var(--btn-border); background:var(--btn-bg); color:var(--text);
      border-radius:10px; padding:10px 12px; font-size:14px;
      transition: box-shadow .12s ease, background .12s ease, transform .04s ease;
    }
    button{cursor:pointer;}
    button:hover{ box-shadow: var(--btn-hover-shadow); }
    button:active{ transform: translateY(0.5px); }
    button:focus-visible{ outline: 2px solid var(--btn-focus); outline-offset: 2px; }
    button:disabled{opacity:.5; cursor:not-allowed;}
    .active{background:var(--btn-active)!important; color:#fff; }

    main{
      position:relative;
      display:grid; grid-template-columns:1fr var(--aside-width); gap:12px; padding:12px;
      transition: grid-template-columns .15s ease;
      height:100%; /* ãƒ˜ãƒƒãƒ€ä»¥å¤–ã¯å¸¸ã«ç”»é¢å†…ã«åã‚ã‚‹ */
      box-sizing:border-box;
    }

    /* å³ãƒ‘ãƒãƒ«æŠ˜ã‚ŠãŸãŸã¿ï¼ˆçªèµ·ã ã‘æ®‹ã™ï¼‰ */
    body.aside-collapsed main{
      grid-template-columns: 1fr var(--aside-collapsed);
    }
    aside{
      order:2; background:var(--panel-bg); color:var(--text); border-radius:14px;
      padding:12px; box-shadow: var(--panel-shadow); overflow:hidden;
      position:relative;
      height:100%;
      display:flex; flex-direction:column;
    }
    .aside-inner{
      height:100%;
      overflow:hidden; /* ã‚µã‚¤ãƒ‰ãƒãƒ¼å†…ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç¦æ­¢ */
    }
    body.aside-collapsed aside{
      padding:0;
    }
    body.aside-collapsed .aside-inner{
      display:none;
    }

    /* ã‚µã‚¤ãƒ‰ãƒãƒ¼çªèµ·ã‚¿ãƒ– */
    #asideTab{
      position:absolute; top:8px; left:-10px;  /* å·¦ã«ã¡ã‚‡ã„çªãå‡ºã™ */
      width:20px; height:28px;
      background:var(--btn-bg); color:var(--text);
      border:1px solid var(--btn-border);
      border-top-left-radius:8px; border-bottom-left-radius:8px; border-right:none;
      display:flex; align-items:center; justify-content:center;
      box-shadow: var(--btn-hover-shadow);
      z-index:5;
      cursor:pointer;
      font-size:12px;
      line-height:1;
    }
    body.aside-collapsed #asideTab{
      left:-1px;
      border-radius:8px;
      width:22px; height:32px;
    }

    .board-wrap{
      order:1; background:var(--panel-bg); color:var(--text);
      border-radius:14px; padding:8px; box-shadow: var(--panel-shadow);
      position:relative; min-height:420px; overflow:hidden;
      height:100%;
    }

    .panel-title{font-size:12px; color:var(--hint); margin:0 0 6px;}
    .toolbar{ display:grid; gap:6px; }
    .group{ border-top:1px dashed var(--soft); padding-top:6px; margin-top:6px; }
    .tool-row{ display:flex; flex-wrap:wrap; align-items:center; gap:6px; }
    select.compact{ padding:6px 8px; font-size:12px; }

    .board{width:100%; height:100%; border-radius:12px; display:block; background:#0b0b0b08; touch-action:none;}

    /* æç”»ã‚­ãƒ£ãƒ³ãƒã‚¹ & ã‚«ãƒ¼ã‚½ãƒ«ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */
    canvas.draw, canvas.cursor-layer{
      position:absolute; inset:8px;
      width:calc(100% - 16px); height:calc(100% - 16px);
      pointer-events:none; touch-action:none;
      border-radius:12px;
    }
    canvas.cursor-layer{ z-index:6; }

    /* æ–¹çœ¼ç·šï¼ˆSVG lineï¼‰ */
    #gridLayer line { pointer-events:none; }

    .shape{fill-opacity:.35; stroke-width:2;}
    .selected{filter:drop-shadow(0 0 0.6px rgba(0,0,0,.25));}
    .handle{fill:#fff; stroke:var(--accent); stroke-width:2; cursor:pointer; r12;}
    .bbox-handle{fill:#fff; stroke:#64748b; stroke-width:2; cursor:nwse-resize;}

    /* ä»˜ç®‹ã®è¦‹ãŸç›®ï¼ˆå¾©å…ƒï¼‰ */
    .note-wrap{ position:relative; width:100%; height:100%; overflow:visible; }
    .note{
      width:100%; height:100%;
      padding:6px 8px 10px 8px;
      border-radius:8px; border:1px solid var(--btn-border);
      background:var(--note-yellow);
      box-shadow:0 2px 6px rgba(0,0,0,.08);
      outline:none; line-height:1.4; overflow:auto; color:var(--text);
    }
    .note-yellow{ background:var(--note-yellow); }
    .note-blue  { background:var(--note-blue); }
    .note-pink  { background:var(--note-pink); }
    .note-close{
      position:absolute; right:4px; top:4px;
      border:none; background:rgba(255,255,255,0.85);
      border:1px solid var(--btn-border); border-radius:6px;
      padding:2px 6px; cursor:pointer; font-size:12px; color:#111;
    }
    [data-theme="dark"] .note-close{ background:rgba(17,24,39,0.9); color:#e5e7eb; }
    .note-resize{
      position:absolute; right:-6px; bottom:-6px; width:18px; height:18px; background:#fff;
      border:1px solid #94a3b8; border-radius:3px; cursor:nwse-resize; box-shadow:0 1px 2px rgba(0,0,0,.1);
    }
    [data-theme="dark"] .note-resize{ background:#1f2937; border-color:#475569; }

    /* ãƒãƒƒã‚¸ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤åŒ–ã—ã¦é«˜ã•ã‚’åœ§ç¸® */
    .badgebar{
      position:absolute; left:12px; bottom:12px; z-index:5;
      display:flex; flex-wrap:wrap; gap:8px; align-items:center;
      pointer-events:none;
    }
    .badge{
      background:var(--badge-bg); color:var(--badge-text);
      border:1px solid var(--badge-border); border-radius:10px; padding:4px 8px; font-size:12px;
    }

    /* ãƒ¢ãƒ¼ãƒ‰ãƒãƒƒã‚¸ï¼ˆå·¦ãƒ»ä¸Šï¼‰ */
    #modeBadge{
      position:absolute; left:12px; top:12px;
      background:rgba(255,255,255,0.9); border:1px solid var(--btn-border); border-radius:10px;
      font-size:12px; padding:4px 8px; z-index:5; pointer-events:none; color:#111;
    }
    [data-theme="dark"] #modeBadge{ background:rgba(17,24,39,0.9); color:#e5e7eb; }

    /* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼ï¼ˆå³ãƒ»ä¸‹ï¼‰ */
    #statusBar{
      position:absolute; right:12px; bottom:12px;
      background:rgba(255,255,255,0.9); border:1px solid var(--btn-border); border-radius:10px;
      font-size:12px; padding:4px 8px; z-index:5; pointer-events:none; min-width: 180px; text-align:right; color:#111;
    }
    [data-theme="dark"] #statusBar{ background:rgba(17,24,39,0.9); color:#e5e7eb; }

    /* ã‚¿ãƒƒãƒç«¯æœ«ï¼šãƒãƒ³ãƒ‰ãƒ«å¤§ãã‚ã€æ“ä½œä½™ç™½ã‚‚æ§ãˆã‚ã« */
    @media (pointer:coarse) {
      .handle { r: 14 !important; }
      .bbox-handle { width: 24px !important; height: 24px !important; }
      button, select, input[type="color"] { padding:10px 12px; }
    }

    /* 768pxï¼ˆiPadç¸¦ï¼‰ã§ã‚‚æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãªã—ã§åã¾ã‚‹èª¿æ•´ */
    @media (max-width: 820px) {
      :root { --aside-width: 360px; }
      header .row { gap:8px; }
      select, input[type="color"], button { padding:8px 10px; font-size:13px; }
      .panel-title { font-size:12px; }
    }
  </style>
</head>
<body>
<header>
  <div class="row">
    <div class="title">Hippoly!</div>

    <label title="æ–¹çœ¼ã®ã‚µã‚¤ã‚ºã‚’åˆ‡ã‚Šæ›¿ãˆï¼ˆ1/3cmï¼‰">æ–¹çœ¼ï¼š
      <select id="gridSize" title="1/3cm æ–¹çœ¼">
        <option value="1">1cm</option>
        <!-- 2cm ã¯å‰Šé™¤ -->
        <option value="3" selected>3cm</option>
      </select>
    </label>

    <button id="undo" title="æˆ»ã‚‹ï¼ˆUndoï¼‰">â†¶ æˆ»ã‚‹</button>
    <button id="redo" title="é€²ã‚€ï¼ˆRedoï¼‰">â†· é€²ã‚€</button>
    <button id="reset" title="ãƒªã‚»ãƒƒãƒˆï¼ˆç”»é¢ã‚’å†èª­ã¿è¾¼ã¿ï¼‰">âŸ² ãƒªã‚»ãƒƒãƒˆ</button>
    <button id="export" title="ä¿å­˜ï¼ˆJSONã¨ã—ã¦ä¿å­˜ï¼‰">ğŸ’¾ ä¿å­˜</button>
    <label id="importLabel" class="toggle" title="èª­ã¿è¾¼ã¿ï¼ˆä¿å­˜ã—ãŸJSONã‚’é¸æŠï¼‰">ğŸ“‚ èª­ã¿è¾¼ã¿
      <input id="import" type="file" accept="application/json" style="display:none">
    </label>

    <!-- ãƒ†ãƒ¼ãƒãƒˆã‚°ãƒ« -->
    <button id="themeToggle" title="ãƒ†ãƒ¼ãƒ">ğŸŒ™</button>

    <!-- ä»˜ç®‹é¸æŠæ™‚ã®ã¿è¡¨ç¤ºã™ã‚‹ãƒ˜ãƒƒãƒ€ãƒ‘ãƒãƒ« -->
    <div id="notePanel" title="ä»˜ç®‹ã®è¦‹ãŸç›®ã‚’å¤‰æ›´" style="display:none; gap:8px; align-items:center; padding:4px 6px; border:1px solid var(--btn-border); border-radius:10px;">
      <label>è‰²
        <select id="noteHdrColor" title="ä»˜ç®‹ã®è‰²ã‚’å¤‰æ›´">
          <option value="yellow">é»„è‰²</option>
          <option value="blue">æ°´è‰²</option>
          <option value="pink">ãƒ”ãƒ³ã‚¯</option>
        </select>
      </label>
      <label>æ–‡å­—ã‚µã‚¤ã‚º
        <select id="noteHdrSize" title="ä»˜ç®‹ã®æ–‡å­—ã‚µã‚¤ã‚ºã‚’å¤‰æ›´">
          <option value="s">å°</option>
          <option value="m" selected>ä¸­</option>
          <option value="l">å¤§</option>
        </select>
      </label>
    </div>
  </div>
</header>

<main>
  <div class="board-wrap">
    <!-- ãƒ¢ãƒ¼ãƒ‰ãƒãƒƒã‚¸ -->
    <div id="modeBadge">ç·¨é›†/ç§»å‹•</div>
    <!-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼ -->
    <div id="statusBar">(x: â€” cm, y: â€” cm) | Snap: â€”</div>

    <svg id="board" class="board" aria-label="draw-board"></svg>
    <canvas id="drawCanvas" class="draw"></canvas>
    <canvas id="cursorCanvas" class="cursor-layer"></canvas>

    <div class="badgebar">
      <span class="badge">é¸æŠ: <strong id="selType">â€”</strong></span>
      <span class="badge"><span id="wLabel">å¹…</span>: <strong id="w">â€”</strong> <span id="u1">cm</span></span>
      <span class="badge"><span id="hLabel">é«˜ã•</span>: <strong id="h">â€”</strong> <span id="u2">cm</span></span>
      <span class="badge">é ‚ç‚¹: <strong id="vh">â€”</strong></span>
    </div>
  </div>

  <aside>
    <button id="asideTab" title="ã‚µã‚¤ãƒ‰ãƒãƒ¼ã‚’ãŸãŸã‚€/ã²ã‚‰ã">â–¶</button>
    <div class="aside-inner">
      <div class="panel-title">ãƒ„ãƒ¼ãƒ«</div>
      <div class="toolbar" id="toolbar">
        <div>
          <button data-tool="edit" class="active" title="ç·¨é›†/ç§»å‹•ï¼ˆé¸æŠãƒ»ç§»å‹•ãƒ»ãƒªã‚µã‚¤ã‚ºãªã©ï¼‰"><span class="icon">âœ‹</span>ç§»å‹•</button>
          <button data-tool="text" title="ä»˜ç®‹ã‚’1æšé…ç½®ï¼ˆé…ç½®å¾Œã¯è‡ªå‹•ã§ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã‚Šã¾ã™ï¼‰"><span class="icon">ğŸ“</span>ã‚³ãƒ¡ãƒ³ãƒˆ</button>
          <div class="group">
            <div class="panel-title">æ‰‹æ›¸ã</div>
            <div class="tool-row">
              <button data-tool="draw" title="ãƒšãƒ³ï¼ˆã‚­ãƒ£ãƒ³ãƒã‚¹ã«è‡ªç”±ç·šã‚’æç”»ï¼‰"><span class="icon">ğŸ–Šï¸</span>ãƒšãƒ³</button>
              <select id="penColor" class="compact" title="ãƒšãƒ³è‰²">
                <option value="#1f2937" selected>é»’</option>
                <option value="#ef4444">èµ¤</option>
                <option value="#2563eb">é’</option>
                <option value="#16a34a">ç·‘</option>
ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€<option value="#f2f6fa">ç™½</option>

              </select>
              <button data-tool="erase" title="æ¶ˆã—ã‚´ãƒ ï¼ˆãƒ”ã‚¯ã‚»ãƒ«/ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ/å…¨æ¶ˆã—ï¼‰"><span class="icon">ğŸ—‘</span>æ¶ˆã—ã‚´ãƒ </button>
              <select id="eraserMode" class="compact" title="æ¶ˆã—ã‚´ãƒ ãƒ¢ãƒ¼ãƒ‰">
                <option value="pixel">ãƒ”ã‚¯ã‚»ãƒ«</option>
                <option value="object">ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ</option>
                <option value="clear">å…¨æ¶ˆã—</option>
              </select>
            </div>
          </div>
        </div>

        <div class="group">
          <div class="panel-title">å›³å½¢</div>
          <div class="tool-row">
            <button data-add="rect" title="é•·æ–¹å½¢ã‚’è¿½åŠ ">â–­ é•·æ–¹å½¢</button>
            <button data-add="tri" title="ä¸‰è§’å½¢ï¼ˆãƒ©ãƒ³ãƒ€ãƒ ï¼‰ã‚’è¿½åŠ ">â–³ ä¸‰è§’å½¢</button>
            <button data-add="trap" title="å°å½¢ï¼ˆ3ãƒ‘ã‚¿ãƒ¼ãƒ³ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ï¼‰ã‚’è¿½åŠ ">â–¡ å°å½¢</button>
            <button data-add="para" title="å¹³è¡Œå››è¾ºå½¢ã‚’è¿½åŠ ">â–± å¹³è¡Œå››è¾ºå½¢</button>
            <button data-add="rh" title="ã²ã—å½¢ã‚’è¿½åŠ ">â—‡ ã²ã—å½¢</button>
          </div>
        </div>

        <div class="group">
          <div class="panel-title">å›³å½¢ç·¨é›†</div>
          <div class="tool-row">
            <label class="toggle"><input type="checkbox" id="vertexEdit"/> é ‚ç‚¹ç·¨é›†</label>
            <label class="toggle"><input type="checkbox" id="lockSize"/> ã‚µã‚¤ã‚ºå›ºå®š</label>
            <label>è‰² <input type="color" id="color" value="#2563eb"/></label>
          </div>
          <div class="tool-row" style="margin-top:6px;">
            <button id="dup" title="é¸æŠå›³å½¢ã‚’ã‚³ãƒ”ãƒ¼">â§‰ ã‚³ãƒ”ãƒ¼</button>
            <button id="front" title="å‰é¢ã¸">â¤´ æ‰‹å‰ã¸</button>
            <button id="back" title="èƒŒé¢ã¸">â¤µ å¥¥ã¸</button>
            <button id="rotL" title="åæ™‚è¨ˆå›ã‚Šã«å›è»¢">â†º å›è»¢</button>
            <button id="rotR" title="æ™‚è¨ˆå›ã‚Šã«å›è»¢">â†» å›è»¢</button>
            <button id="flipH" title="å·¦å³åè»¢">â‡” åè»¢</button>
            <button id="flipV" title="ä¸Šä¸‹åè»¢">â‡• åè»¢</button>
            <button id="deleteShape" title="é¸æŠå›³å½¢ã‚’å‰Šé™¤">âœ– å‰Šé™¤</button>
          </div>
        </div>

        <div class="group">
          <div class="panel-title">åˆ†å‰²</div>
          <div class="tool-row">
            <button data-tool="splitLine" title="ç›´ç·šã§åˆ†å‰²ï¼ˆè¤‡æ•°å›³å½¢ã«ã‚‚å¯¾å¿œï¼‰"><span class="icon">âœ‚ï¸</span>ç›´ç·šã§åˆ†å‰²</button>
            <label class="toggle" title="åˆ†å‰²ç·šã‚’æ–¹çœ¼ã«å¸ç€ã•ã›ã‚‹">
              <input type="checkbox" id="splitGridSnap"/> ç·šã«ãã£ã¦åˆ‡ã‚Šã¨ã‚‹
            </label>
          </div>
        </div>
      </div>
    </div>
  </aside>
</main>

<script>
  // ========= åŸºæœ¬ =========
  const svgNS='http://www.w3.org/2000/svg';
  const board=document.getElementById('board');
  const drawCanvas=document.getElementById('drawCanvas');
  const cursorCanvas=document.getElementById('cursorCanvas');
  const ctx=drawCanvas.getContext('2d');
  const cctx=cursorCanvas.getContext('2d');
  const pxPerCm=parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--grid-cm'))||37.7952755906;
  const GRID_PAD = 8; // æ–¹çœ¼ã®å†…å´ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ï¼ˆæç”»ãƒ»å½“ãŸã‚Šåˆ¤å®šãƒ»ç”Ÿæˆã«çµ±ä¸€ä½¿ç”¨ï¼‰

  function el(name, attrs={}){ const n=document.createElementNS(svgNS,name); for(const k in attrs) n.setAttribute(k, attrs[k]); return n; }
  function uid(){ return 's'+Math.random().toString(36).slice(2,9); }

  // ========= çŠ¶æ…‹ =========
  const state={
    tool:'edit',
    gridPx:pxPerCm*3,
    gridOffset:0,
    snapTol:16,
    shapes:[],
    notes:[],
    drawings:[],
    eraseStrokes:[], // ãƒã‚¹ã‚¯
    sel:null,
    selNoteId:null,
    dragging:null,
    lockSize:false,
    vertexEdit:false,
    history:[],
    future:[],
    penColor:'#1f2937',
    eraserMode:'pixel',
    splitPreview:null,
    splitGridSnap:false,
    pointerCaptured:false,
    dpr: Math.max(1, window.devicePixelRatio || 1),
    pointerPos:{x:0,y:0},
    splitStart:null,
    splitPinEl:null
  };

  const ui={
    selType:document.getElementById('selType'), w:document.getElementById('w'), h:document.getElementById('h'), vh:document.getElementById('vh'),
    wLabel:document.getElementById('wLabel'), hLabel:document.getElementById('hLabel'),
    color:document.getElementById('color'), lockSize:document.getElementById('lockSize'),
    dup:document.getElementById('dup'), front:document.getElementById('front'), back:document.getElementById('back'),
    rotL:document.getElementById('rotL'), rotR:document.getElementById('rotR'), flipH:document.getElementById('flipH'), flipV:document.getElementById('flipV'),
    deleteShape:document.getElementById('deleteShape'),
    toolbar:document.getElementById('toolbar'), undo:document.getElementById('undo'), redo:document.getElementById('redo'),
    exportBtn:document.getElementById('export'), importInput:document.getElementById('import'),
    penColor:document.getElementById('penColor'), eraserMode:document.getElementById('eraserMode'),
    gridSize:document.getElementById('gridSize'), splitGridSnap:document.getElementById('splitGridSnap'),
    vertexEdit:document.getElementById('vertexEdit'),
    resetBtn:document.getElementById('reset'),
    notePanel:document.getElementById('notePanel'),
    noteHdrColor:document.getElementById('noteHdrColor'),
    noteHdrSize:document.getElementById('noteHdrSize'),
    modeBadge:document.getElementById('modeBadge'),
    statusBar:document.getElementById('statusBar'),
    themeToggle:document.getElementById('themeToggle'),
    asideTab:document.getElementById('asideTab')
  };

  // ========= ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå®‰å®šåŒ–ï¼ˆæ–¹çœ¼ã¨ã‚µã‚¤ãƒ‰ãƒãƒ¼ã®é«˜ã•ä¸€è‡´ï¼‰ =========
  function ensureLayout(){
    const header=document.querySelector('header');
    const wrap=document.querySelector('.board-wrap');
    const aside=document.querySelector('aside');
    const hHeader=header?header.getBoundingClientRect().height:0;

    const avail=Math.max(420, window.innerHeight - hHeader - 24);
    if(wrap) wrap.style.height=avail+'px';
    if(aside) aside.style.height=avail+'px';

    setSvgSizeByClient();
  }
  function setSvgSizeByClient(){
    const r=board.getBoundingClientRect();
    const w=Math.max(1, Math.floor(r.width));
    const h=Math.max(1, Math.floor(r.height));
    board.setAttribute('width', w);
    board.setAttribute('height', h);
    setupCanvasDPR(drawCanvas, ctx, w, h);
    setupCanvasDPR(cursorCanvas, cctx, w, h);
    return {w,h};
  }
  function setupCanvasDPR(canvas, context, cssW, cssH){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    state.dpr = dpr;
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.width  = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);
    context.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  // â˜… visualViewport/resize ã§ã‚ºãƒ¼ãƒ ã‚„DPRå¤‰åŒ–ã‚’æ¤œçŸ¥ â†’ å†åˆæœŸåŒ–
	let __vpTick = null;
	function onViewportChange() {
 		if (__vpTick) cancelAnimationFrame(__vpTick);
  	__vpTick = requestAnimationFrame(()=>{
    	ensureLayout();
    	drawGrid();        // setSvgSizeByClient() å†…ã§ Canvas/SVG ã‚’ã‚µã‚¤ã‚ºæ›´æ–°
    	render();
    	redrawCursorOverlay();
  	});
	}

  // ========= æ–¹çœ¼æç”»ï¼ˆSVG lineã§å®‰å®šæç”»ï¼‰ =========
  function drawGrid(){
    while(board.firstChild) board.removeChild(board.firstChild);
    const {w,h}=setSvgSizeByClient();
    if(!w||!h) return;

    const grid = el('g', { id:'gridLayer' });
    const color = (getComputedStyle(document.documentElement).getPropertyValue('--grid-stroke')||'#bfdbfe').trim();
    const lw = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--grid-pt')) || 1.0;
    const g = state.gridPx;

    const pixelW = lw * state.dpr;
		const pxOffset = (Math.round(pixelW) % 2 === 1) ? 0.5 : 0;
    state.gridOffset = pxOffset;

		for(let x=0; x<=w+1; x+=g){
  		const xx = x + pxOffset;
  		grid.appendChild(el('line', { x1: xx, y1: 0, x2: xx, y2: h, stroke: color, 'stroke-width': lw, 'shape-rendering':'crispEdges' }));
		}
    for(let y=0; y<=h+1; y+=g){
  		const yy = y + pxOffset;
  		grid.appendChild(el('line', { x1: 0, y1: yy, x2: w, y2: yy, stroke: color, 'stroke-width': lw, 'shape-rendering':'crispEdges' }));
		}
    board.appendChild(grid);
    board.appendChild(el('g',{id:'shapesLayer'}));
    board.appendChild(el('g',{id:'handlesLayer'}));
    board.appendChild(el('g',{id:'textLayer'}));
  }
  function ensureLayers(){
    const ids=['gridLayer','shapesLayer','handlesLayer','textLayer'];
    for(const id of ids){
      if(!document.getElementById(id)) board.appendChild(el('g',{id}));
    }
  }

  // ========= å›³å½¢ç”Ÿæˆï¼ˆå¸¸ã«æ–¹çœ¼äº¤ç‚¹ä¸Šã«é ‚ç‚¹ï¼‰ =========
  function gridPoint(n, m){ // n,m ã¯æ•´æ•°
 		return [n*state.gridPx, m*state.gridPx];
	}
  function addShape(type){
    const g=state.gridPx;
    // ç”»é¢å·¦ä¸Šã‹ã‚‰2ãƒã‚¹å³ãƒ»2ãƒã‚¹ä¸‹ã‚’åŸºæº–ã«ã€ã™ã¹ã¦æ–¹çœ¼äº¤ç‚¹ã§æ§‹æˆ
    const baseN=2, baseM=2;
    const A = gridPoint(baseN, baseM);
    const B = gridPoint(baseN+3, baseM);
    const C = gridPoint(baseN+3, baseM+2);
    const D = gridPoint(baseN,   baseM+2);

    let pts=[];
    if(type==='rect') pts=[A,B,C,D];
    if(type==='tri')  pts=[A, gridPoint(baseN+2, baseM+1), gridPoint(baseN+1, baseM+2)];
    if(type==='trap'){
      const v=Math.floor(Math.random()*3);
      if(v===0) pts=[A, B, gridPoint(baseN+2, baseM+2), gridPoint(baseN+1, baseM+2)];
      else if(v===1) pts=[gridPoint(baseN+1, baseM), gridPoint(baseN+2, baseM), C, D];
      else           pts=[A, gridPoint(baseN+2, baseM), C, D];
    }
    if(type==='para') pts=[A, B, gridPoint(baseN+4, baseM+2), gridPoint(baseN+1, baseM+2)];
    if(type==='rh')   pts=[gridPoint(baseN+1, baseM), gridPoint(baseN+2, baseM+1), gridPoint(baseN+1, baseM+2), gridPoint(baseN, baseM+1)];

    const sh={id:uid(), type, points:pts, fill:ui.color.value, stroke:ui.color.value};
    state.shapes.push(sh);
    selectShape(sh);
    pushHistory(); render();
  }

  // ========= ä»˜ç®‹ =========
  function addNote(x,y){
		const dpx = Math.round(pxPerCm * 0.5); // 5mm â‰’ 0.5cm
		const n={id:uid(), x, y, w:160 + dpx, h:80 + dpx, html:'ãƒ¡ãƒ¢', color:'yellow', font:'m'};
    state.notes.push(n);
    state.selNoteId=n.id;
    pushHistory(); render();
    setTool('edit');
  }
  function noteBgClass(color){
    return color==='pink' ? 'note-pink' : color==='blue' ? 'note-blue' : 'note-yellow';
  }
  function fontPt(font){ return font==='s' ? '10pt' : font==='l' ? '18pt' : '13pt'; }

  function renderNotes(){
    const textLayer=document.getElementById('textLayer');
    [...textLayer.querySelectorAll('foreignObject')].forEach(n=>n.remove());

    for(const n of state.notes){
      const fo=el('foreignObject',{x:n.x, y:n.y, width:n.w, height:n.h, 'data-nid':n.id});
      const wrap=document.createElement('div'); wrap.className='note-wrap';

      const div=document.createElement('div');
      div.className=`note ${noteBgClass(n.color)}`;
      div.contentEditable='true';
      div.style.fontSize = fontPt(n.font);
      div.innerHTML=n.html;

      const close=document.createElement('button');
      close.className='note-close';
      close.textContent='âœ•';
      close.title='ä»˜ç®‹ã‚’å‰Šé™¤';

      const grip=document.createElement('div'); grip.className='note-resize'; grip.title='ã‚µã‚¤ã‚ºå¤‰æ›´';

      wrap.appendChild(div);
      wrap.appendChild(close);
      wrap.appendChild(grip);
      fo.appendChild(wrap);
      textLayer.appendChild(fo);

      div.addEventListener('pointerdown',(e)=>{
  			e.stopPropagation();
  			state.selNoteId=n.id;
			  updateNoteHeaderPanel();
  			const startPt = pt(e);
  			state.dragging={mode:'notePending', note:n, start:startPt, ox:n.x, oy:n.y};
			  try{board.setPointerCapture(e.pointerId);}catch(_){}
			});
      div.addEventListener('input', ()=>{ n.html=div.innerHTML; });
      div.addEventListener('blur', ()=>{ n.html=div.innerHTML; pushHistory(); });

      close.addEventListener('pointerdown', (e)=>{ e.stopPropagation(); });
      close.addEventListener('click', (e)=>{
        e.stopPropagation();
        state.notes = state.notes.filter(x=>x.id!==n.id);
        if(state.selNoteId===n.id) state.selNoteId=null;
        pushHistory(); render();
      });

      grip.addEventListener('pointerdown',(e)=>{
        e.stopPropagation();
        state.selNoteId=n.id;
        updateNoteHeaderPanel();
        state.dragging={mode:'noteResize', note:n, start:pt(e), ow:n.w, oh:n.h};
        try{board.setPointerCapture(e.pointerId);}catch(_){}
      });
    }
  }

  // ========= ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚° =========
  function ptsToAttr(pts){ return pts.map(p=>p.join(',')).join(' '); }
  function bbox(pts){ const xs=pts.map(p=>p[0]), ys=pts.map(p=>p[1]); const x=Math.min(...xs), y=Math.min(...ys), w=Math.max(...xs)-x, h=Math.max(...ys)-y; return {x,y,w,h}; }
  function centroid(pts){ const s=pts.reduce((a,p)=>({x:a.x+p[0],y:a.y+p[1]}),{x:0,y:0}); return {x:s.x/pts.length,y:s.y/pts.length}; }

  function render(){
    ensureLayers();
    const layer=document.getElementById('shapesLayer');
    const handles=document.getElementById('handlesLayer');
    layer.innerHTML=''; handles.innerHTML='';

    for(const sh of state.shapes){
      const p=el('polygon',{points:ptsToAttr(sh.points), fill:sh.fill, stroke:sh.stroke, 'stroke-linejoin':'round', class:'shape'+(state.sel&&state.sel.id===sh.id?' selected':'')});
      p.dataset.id=sh.id; layer.appendChild(p);
      if(state.sel && state.sel.id===sh.id){
        if(state.vertexEdit){
          sh.points.forEach((pt,i)=> handles.appendChild(el('circle',{cx:pt[0],cy:pt[1],r:12,class:'handle','data-vidx':i,'data-id':sh.id})));
        }else{
          const bb=bbox(sh.points);
          const hs=[
            {x:bb.x,y:bb.y,c:'nw'},{x:bb.x+bb.w/2,y:bb.y,c:'n'},{x:bb.x+bb.w,y:bb.y,c:'ne'},
            {x:bb.x,y:bb.y+bb.h/2,c:'w'},{x:bb.x+bb.w,y:bb.y+bb.h/2,c:'e'},
            {x:bb.x,y:bb.y+bb.h,c:'sw'},{x:bb.x+bb.w/2,y:bb.y+bb.h,c:'s'},{x:bb.x+bb.w,y:bb.y+bb.h,c:'se'}
          ];
          hs.forEach(h=>{const r=el('rect',{x:h.x-10,y:h.y-10,width:20,height:20,rx:4,class:'bbox-handle'}); r.dataset.id=sh.id; r.dataset.corner=h.c; handles.appendChild(r);});
          handles.appendChild(el('rect',{x:bb.x,y:bb.y,width:bb.w,height:bb.h,fill:'none',stroke:'#94a3b8','stroke-dasharray':'6 4'}));
        }
      }
    }
    renderNotes();
    updateBadges();
    updateNoteHeaderPanel();
    updateModeBadge();
    setCanvasInteractivity();
    redrawCanvas();
    redrawCursorOverlay();
  }

  // ========= ã‚¹ãƒŠãƒƒãƒ—ç­‰ =========
  function pt(e){
  	// ã‚¤ãƒ™ãƒ³ãƒˆã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®å®Ÿ DOM ã«åˆã‚ã›ã¦åº§æ¨™ã‚’å–ã‚‹ï¼ˆcanvas ã¯ board å†…ã§ 8px insetï¼‰
  	const tgt = (e.currentTarget && (e.currentTarget.getBoundingClientRect?.() ? e.currentTarget : null)) || board;
  	const bb = tgt.getBoundingClientRect();
  	return { x: e.clientX - bb.left, y: e.clientY - bb.top };
	}
  function dist(x1,y1,x2,y2){ const dx=x1-x2, dy=y1-y2; return Math.hypot(dx,dy); }
  function segI(A,B,C,D){
    const den=(B[0]-A[0])*(D[1]-C[1])-(B[1]-A[1])*(D[0]-C[0]);
    if(Math.abs(den)<1e-6) return null;
    const t=((C[0]-A[0])*(D[1]-C[1])-(C[1]-A[1])*(D[0]-C[0]))/den;
    const u=((C[0]-A[0])*(B[1]-A[1])-(C[1]-A[1])*(B[0]-A[0]))/den;
    if(t<0||t>1||u<0||u>1) return null;
    return {x:A[0]+t*(B[0]-A[0]), y:A[1]+t*(B[1]-A[1])};
  }
  function candidates(){
    const pts=[]; const segs=[];
    for(const sh of state.shapes){
      const n=sh.points.length;
      for(let i=0;i<n;i++){
        const a=sh.points[i], b=sh.points[(i+1)%n];
        pts.push(a);
        pts.push([(a[0]+b[0])/2,(a[1]+b[1])/2]);
        segs.push([a,b]);
      }
    }
    for(let i=0;i<segs.length;i++) for(let j=i+1;j<segs.length;j++){ const I=segI(segs[i][0],segs[i][1],segs[j][0],segs[j][1]); if(I) pts.push([I.x,I.y]); }
    candidates._segs=segs; return pts;
  }
  function snapPoint(x,y){
    const pts=candidates();
		const off = state.gridOffset || GRID_PAD;
		const gx = Math.round((x - off)/state.gridPx)*state.gridPx + off;
		const gy = Math.round((y - off)/state.gridPx)*state.gridPx + off;
    pts.push([gx,gy]);
    let best=null, bestd=state.snapTol+1;
    for(const c of pts){ const d=dist(x,y,c[0],c[1]); if(d<bestd){ bestd=d; best={x:c[0],y:c[1]}; } }
    return bestd<=state.snapTol?best:null;
  }
  function projectPointToSeg(p,a,b){
    const ax=a[0], ay=a[1], bx=b[0], by=b[1];
    const abx=bx-ax, aby=by-ay; const apx=p.x-ax, apy=p.y-ay; const ab2=abx*abx+aby*aby; if(ab2===0) return null;
    let t=(apx*abx+apy*aby)/ab2; if(t<0||t>1) return null; const x=ax+t*abx, y=ay+t*aby; const d=dist(p.x,p.y,x,y); return {x,y,d};
  }
  function projectToSegments(x,y){
    const segs=candidates._segs||[]; let best=null, bestd=state.snapTol+1;
    for(const s of segs){ const pr=projectPointToSeg({x,y}, s[0], s[1]); if(pr && pr.d<bestd){ best=pr; bestd=pr.d; } }
    return best && best.d<=state.snapTol?{x:best.x,y:best.y}:null;
  }
  function snapPointWithProjection(x,y){ return snapPoint(x,y) || projectToSegments(x,y); }

  function clampToBoard(pts, W, H){
    const bb=bbox(pts); let dx=0, dy=0;
    if(bb.x<GRID_PAD) dx=GRID_PAD-bb.x; if(bb.y<GRID_PAD) dy=GRID_PAD-bb.y;
    if(bb.x+bb.w>W-GRID_PAD) dx = (W-GRID_PAD)-(bb.x+bb.w);
    if(bb.y+bb.h>H-GRID_PAD) dy = (H-GRID_PAD)-(bb.y+bb.h);
    return pts.map(p=>[p[0]+dx, p[1]+dy]);
  }
  function nearestFrame(x,y){
    const W=board.clientWidth, H=board.clientHeight;
    const dTop=Math.abs(y-GRID_PAD), dBottom=Math.abs((H-GRID_PAD)-y), dLeft=Math.abs(x-GRID_PAD), dRight=Math.abs((W-GRID_PAD)-x);
    const m=Math.min(dTop,dBottom,dLeft,dRight);
    if(m===dTop) return {x:x,y:GRID_PAD,d:m,axis:'h',value:GRID_PAD};
    if(m===dBottom) return {x:x,y:H-GRID_PAD,d:m,axis:'h',value:H-GRID_PAD};
    if(m===dLeft) return {x:GRID_PAD,y:y,d:m,axis:'v',value:GRID_PAD};
    return {x:W-GRID_PAD,y:y,d:m,axis:'v',value:W-GRID_PAD};
  }

  // ========= ç›´ç·šåˆ†å‰² =========
  function splitSnapOnce(p){
    const tol=state.snapTol;
    for(const sh of state.shapes){
      for(const v of sh.points){
        if(dist(p.x,p.y,v[0],v[1])<=tol) return {pt:{x:v[0],y:v[1]}, lock:null, anchor:'vertex'};
      }
    }
    if(state.splitGridSnap){
      const gx=Math.round((p.x-GRID_PAD)/state.gridPx)*state.gridPx + GRID_PAD;
      const gy=Math.round((p.y-GRID_PAD)/state.gridPx)*state.gridPx + GRID_PAD;
      const dx=Math.abs(p.x-gx), dy=Math.abs(p.y-gy);
      if(Math.hypot(dx,dy)<=tol) return {pt:{x:gx,y:gy}, lock:null, anchor:'gridPoint'};
      if(dx<=tol && dx<=dy) return {pt:{x:gx,y:p.y}, lock:{axis:'v',value:gx}, anchor:'gridLine'};
      if(dy<=tol) return {pt:{x:p.x,y:gy}, lock:{axis:'h',value:gy}, anchor:'gridLine'};
    }
    const frame=nearestFrame(p.x,p.y);
    if(frame && frame.d<=tol) return {pt:{x:frame.x,y:frame.y}, lock:{axis:frame.axis,value:frame.value}, anchor:'frame'};
    return {pt:{x:p.x,y:p.y}, lock:null, anchor:'free'};
  }
  function splitSnapMove(p, existingLock, anchor, isShift){
    const tol=state.snapTol;
    if(existingLock){
      if(existingLock.axis==='h') return {pt:{x:p.x,y:existingLock.value}, lock:existingLock};
      if(existingLock.axis==='v') return {pt:{x:existingLock.value,y:p.y}, lock:existingLock};
    }
    for(const sh of state.shapes){
      for(const v of sh.points){
        if(dist(p.x,p.y,v[0],v[1])<=tol) return {pt:{x:v[0],y:v[1]}, lock:null};
      }
    }
    if(state.splitGridSnap){
      const gx=Math.round((p.x-GRID_PAD)/state.gridPx)*state.gridPx + GRID_PAD;
      const gy=Math.round((p.y-GRID_PAD)/state.gridPx)*state.gridPx + GRID_PAD;
      const dx=Math.abs(p.x-gx), dy=Math.abs(p.y-gy);
      if(Math.hypot(dx,dy)<=tol) return {pt:{x:gx,y:gy}, lock:null};
      if(anchor!=='vertex' || isShift){
        if(dx<=tol && dx<=dy) return {pt:{x:gx,y:p.y}, lock:{axis:'v',value:gx}};
        if(dy<=tol)           return {pt:{x:p.x,y:gy}, lock:{axis:'h',value:gy}};
      }
    }
    if(anchor!=='vertex' || isShift){
      const frame=nearestFrame(p.x,p.y);
      if(frame && frame.d<=tol) return {pt:{x:frame.x,y:frame.y}, lock:{axis:frame.axis,value:frame.value}};
    }
    return {pt:{x:p.x,y:p.y}, lock:null};
  }

  // å§‹ç‚¹ãƒ”ãƒ³
  function updateSplitPin(a){
    const hl=document.getElementById('handlesLayer');
    if(!hl) return;
    if(!a){
      if(state.splitPinEl){ state.splitPinEl.remove(); state.splitPinEl=null; }
      return;
    }
    if(!state.splitPinEl){
      state.splitPinEl = el('circle', { r:4, fill:'#ef4444', opacity:'1.0' });
      hl.appendChild(state.splitPinEl);
    }
    state.splitPinEl.setAttribute('cx', a.x);
    state.splitPinEl.setAttribute('cy', a.y);
  }
  function drawSplitPreview(a,b){
    ensureLayers();
    const hl=document.getElementById('handlesLayer');
    if(state.splitPreview) state.splitPreview.remove();
    const line=el('path',{d:`M ${a.x} ${a.y} L ${b.x} ${b.y}`, stroke:'#ef4444','stroke-dasharray':'6 4', fill:'none'});
    hl.appendChild(line); state.splitPreview=line;
    updateSplitPin(a);
  }

  // ========= UI =========
  function setTool(name){
    state.tool = name;
    [...ui.toolbar.querySelectorAll('button')].forEach(x=>x.classList.remove('active'));
    const btn = ui.toolbar.querySelector(`button[data-tool="${name}"]`);
    if (btn) btn.classList.add('active');
    setCanvasInteractivity();
    updateModeBadge();
    redrawCursorOverlay();
  }
  function selectShape(sh){ state.sel=sh; state.selNoteId=null; if(sh) ui.color.value=sh.fill; render(); }

  // board pointerdown
  board.addEventListener('pointerdown', (e)=>{
    if(state.tool==='draw' || state.tool==='erase') return;
    const p=pt(e); state.pointerPos = p; redrawCursorOverlay();

    const target=e.target;
    const id=target && target.dataset ? target.dataset.id : null;
    const isVHandle=target.classList && target.classList.contains('handle');
    const isBBoxHandle=target.classList && target.classList.contains('bbox-handle');

    if(state.tool==='text'){
      addNote(p.x, p.y);
      return;
    }
    if(state.tool==='splitLine'){
      const s=splitSnapOnce(p);
      state.dragging={mode:'split', a:s.pt, b:s.pt, lock:s.lock, anchor:s.anchor};
      drawSplitPreview(state.dragging.a, state.dragging.b);
      return;
    }

    if(state.sel && !state.vertexEdit && isBBoxHandle){
		  if(state.lockSize) return;
		  const bb0 = bbox(state.sel.points);
		  state.dragging={
		    mode:'bbox',
        sh: state.sel,
        corner: target.dataset.corner,
        start: p,
        initBB: bb0,                       // â˜… ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹æ™‚ã®BBoxã‚’å›ºå®šä¿å­˜
				initPts: state.sel.points.map(q=>q.slice()) // â˜… å…ƒé ‚ç‚¹ç¾¤ã‚’ä¿å­˜
			};
			return;
    }
    if(isVHandle){
  		if(state.lockSize) return;
  		// â˜… é ‚ç‚¹ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹æ™‚ã«ã€Œå…ƒã®é ‚ç‚¹é…åˆ—ã€ã‚’ä¿æŒã—ã¦ãŠã
  		state.dragging={
    		mode:'vertex',
    		sh: state.sel,
    		vidx: +target.getAttribute('data-vidx'),
    		initPts: state.sel.points.map(q=>q.slice())
  		};
  		try{ board.setPointerCapture(e.pointerId); }catch(_){}
  		return;
		}

    state.sel=null; state.selNoteId=null; updateNoteHeaderPanel(); render();

    if(id){
  		const sh=state.shapes.find(s=>s.id===id);
  		selectShape(sh);

  		// ä¸€ç•ªè¿‘ã„é ‚ç‚¹ã‚’ã‚¢ãƒ³ã‚«ãƒ¼ã«
  		let anchorIdx = 0, best = 1e9;
  		sh.points.forEach((q,i)=>{
    		const d = Math.hypot(q[0]-p.x, q[1]-p.y);
    		if(d < best){ best = d; anchorIdx = i; }
  		});
  		const anchorStart = sh.points[anchorIdx];

  		// ãƒã‚¤ãƒ³ã‚¿ä½ç½®ã®ã‚¹ãƒŠãƒƒãƒ—èµ·ç‚¹ï¼ˆè¾ºãƒ»ä¸­ç‚¹ãƒ»é ‚ç‚¹ãƒ»ã‚°ãƒªãƒƒãƒ‰ã‚’è¨±å®¹ï¼‰
  		const sStart = snapPointWithProjection(p.x, p.y) || {x:p.x, y:p.y};

  		// â˜… é‡è¦ï¼šæŒ‡ã¨åŸºæº–é ‚ç‚¹ã®å·®åˆ†ã‚’ä¿å­˜ï¼ˆã“ã‚ŒãŒç„¡ã„ã¨é–‹å§‹æ™‚ã«å›³å½¢ãŒâ€œå¯„ã£ã¦â€ã—ã¾ã†ï¼‰
  		const anchorOffset = {
    		ox: anchorStart[0] - sStart.x,
    		oy: anchorStart[1] - sStart.y
  		};

  		state.dragging = {
    		mode:'move',
    		sh,
    		startPt: p,
    		initPts: sh.points.map(q=>q.slice()),
    		anchorIdx,
    		anchorStart,
    		anchorOffset
  		};
		}
  });

  // drawCanvas pointer
  drawCanvas.addEventListener('pointerdown', (e)=>{
    const p = pt(e);
    state.pointerPos = p; redrawCursorOverlay();
    if (state.tool==='draw'){
      e.preventDefault();
      state.dragging={mode:'draw', stroke:{id:uid(), color: state.penColor, pts:[[p.x,p.y]]}};
      try{ drawCanvas.setPointerCapture(e.pointerId); state.pointerCaptured=true; }catch(_){}
      redrawCanvas();
      return;
    }
    if (state.tool==='erase'){
      e.preventDefault();
      handleEraserDown(e, p);
      return;
    }
  }, {passive:false});

  drawCanvas.addEventListener('pointermove', (e)=>{
    const p=pt(e); state.pointerPos = p; redrawCursorOverlay();
    if(!state.dragging) { updateStatusFromEvent(e); return; }
    if(state.dragging.mode==='draw'){
      e.preventDefault();
      addStrokePoint(p);
      redrawCanvas();
    }else if(state.dragging.mode==='erasePixel'){
      e.preventDefault();
      addErasePoint(p);
      redrawCanvas();
    }
    updateStatusFromEvent(e);
  }, {passive:false});

  drawCanvas.addEventListener('pointerup', onPointerUpOrCancel, {passive:false});
  drawCanvas.addEventListener('pointercancel', onPointerUpOrCancel, {passive:false});

  // board pointermove
  board.addEventListener('pointermove', (e)=>{
    const p=pt(e); state.pointerPos = p; redrawCursorOverlay();
    if(!state.dragging) { updateStatusFromEvent(e); return; }
    const W=board.clientWidth, H=board.clientHeight;

    if(state.dragging.mode==='move'){
  		const {sh, initPts, anchorStart, anchorOffset} = state.dragging;

  		// ç¾åœ¨ã®ãƒã‚¤ãƒ³ã‚¿ã‚’ã‚¹ãƒŠãƒƒãƒ—
  		const sNow = snapPointWithProjection(p.x, p.y) || {x:p.x, y:p.y};

  		// â˜… â€œé–‹å§‹æ™‚ã®æŒ‡ã¨åŸºæº–é ‚ç‚¹ã®å·®åˆ†â€ã‚’ç¶­æŒã—ãŸã¾ã¾ç§»å‹•
  		const dx = (sNow.x + anchorOffset.ox) - anchorStart[0];
  		const dy = (sNow.y + anchorOffset.oy) - anchorStart[1];

  		// åˆæœŸé ‚ç‚¹ç¾¤ã‹ã‚‰çµ¶å¯¾å¹³è¡Œç§»å‹•ï¼ˆç´¯ç©èª¤å·®ãªã—ï¼‰
  		const moved = initPts.map(q=>[q[0]+dx, q[1]+dy]);

  		// è¦‹ãŸç›®ã‚°ãƒªãƒƒãƒ‰ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã§ä¸¸ã‚ï¼ˆ0.5px ã‚’è€ƒæ…®ï¼‰
  		const g = state.gridPx, off = state.gridOffset || 0, eps = 0.25; // px
  		sh.points = moved.map(([x,y])=>{
    		const rx = Math.round((x-off)/g)*g + off;
    		const ry = Math.round((y-off)/g)*g + off;
    		return [
      		Math.abs(x-rx) <= eps ? rx : x,
      		Math.abs(y-ry) <= eps ? ry : y
    		];
  		});

  		sh.points = clampToBoard(sh.points, W, H);
  		render();
		}else if(state.dragging.mode==='bbox'){
  		const {sh,corner,initBB,initPts}=state.dragging;
  		// ãƒã‚¤ãƒ³ã‚¿ä½ç½®ã‹ã‚‰çµ¶å¯¾ã‚¹ã‚±ãƒ¼ãƒ«ã€‚è¾ºã¯å†…éƒ¨ã§ã‚°ãƒªãƒƒãƒ‰ä¸¸ã‚ã•ã‚Œã‚‹
  		resizeByBBoxSnap(sh, corner, initBB, initPts, {x:p.x, y:p.y});
  		sh.points = clampToBoard(sh.points, W, H);
  		render();
		
    }else if(state.dragging.mode==='vertex'){
  		const { sh, vidx, initPts } = state.dragging;

  		// ã‚¹ãƒŠãƒƒãƒ—å€™è£œï¼ˆé ‚ç‚¹/ä¸­ç‚¹/è¾º/ã‚°ãƒªãƒƒãƒ‰ï¼‰
  		const s = snapPointWithProjection(p.x, p.y) || { x:p.x, y:p.y };

  		// è¦‹ãŸç›®ã®ã‚°ãƒªãƒƒãƒ‰ã«â€œå®Œå…¨å¸ç€â€ï¼ˆ0.5pxè£œæ­£ã‚ã‚Šï¼‰
  		const g   = state.gridPx;
  		const off = state.gridOffset || 0;  // drawGrid() ã§ç®—å‡ºã—ã¦ã„ã‚‹è£œæ­£
  		const gx  = Math.round((s.x - off) / g) * g + off;
  		const gy  = Math.round((s.y - off) / g) * g + off;

  		// â˜… ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹æ™‚ã®é…åˆ—ã‚’ãƒ™ãƒ¼ã‚¹ã«ã€å½“è©²é ‚ç‚¹ã ã‘ã‚’æ›´æ–°
  		const pts = initPts.slice();
  		pts[vidx] = [gx, gy];

  		sh.points = clampToBoard(pts, W, H);
  		render();
      
    }else if(state.dragging.mode==='notePending'){
			const {note,start,ox,oy}=state.dragging;
 			// 3px ä»¥ä¸Šå‹•ã„ãŸã‚‰ã€Œç§»å‹•ã€æ‰±ã„ã«æ˜‡æ ¼ï¼ˆé•·æŠ¼ã—é¸æŠã¨è¡çªã—ã«ããã™ã‚‹ï¼‰
 			if (Math.hypot(p.x - start.x, p.y - start.y) > 3) {
    			state.dragging.mode = 'noteMove';
  		}
    }else if(state.dragging.mode==='noteMove'){
      const {note,start,ox,oy}=state.dragging;
      note.x = ox + (p.x-start.x);
      note.y = oy + (p.y-start.y);
      renderNotes();
    }else if(state.dragging.mode==='noteResize'){
      const {note,start,ow,oh}=state.dragging;
      note.w = Math.max(80, ow + (p.x-start.x));
      note.h = Math.max(40, oh + (p.y-start.y));
      renderNotes();
    }else if(state.dragging.mode==='split'){
      const isShift=!!e.shiftKey;
      const snap=splitSnapMove(p, state.dragging.lock, state.dragging.anchor, isShift);
      state.dragging.b=snap.pt;
      if(state.dragging.lock==null && snap.lock) state.dragging.lock=snap.lock;
      drawSplitPreview(state.dragging.a, state.dragging.b);
    }
    updateStatusFromEvent(e);
  }, {passive:false});

  // çµ‚äº†å‡¦ç†
  board.addEventListener('pointerup', onPointerUpOrCancel, {passive:false});
  board.addEventListener('pointercancel', onPointerUpOrCancel, {passive:false});
  window.addEventListener('pointerup', onPointerUpOrCancel, {passive:false});
  window.addEventListener('pointercancel', onPointerUpOrCancel, {passive:false});
  window.addEventListener('blur', onPointerUpOrCancel);

  function onPointerUpOrCancel(e){
    if(!state.dragging) return;
    const m=state.dragging.mode;
    if(m==='move' || m==='vertex' || m==='bbox' || m==='noteMove' || m==='noteResize'){ pushHistory(); }
    if(m==='draw'){ finishStroke(); pushHistory(); redrawCanvas(); }
    if(m==='erasePixel'){ finishEraseStroke(); pushHistory(); redrawCanvas(); }
    if(m==='split'){ finishSplit(); pushHistory(); }
    if(state.pointerCaptured){ try{ drawCanvas.releasePointerCapture(e.pointerId); }catch(_){ } state.pointerCaptured=false; }
    state.dragging=null;
    redrawCursorOverlay();
  }

  // bbox ãƒªã‚µã‚¤ã‚º
  // â˜… ã‚°ãƒªãƒƒãƒ‰ã«â€œçµ¶å¯¾å¸ç€â€ã™ã‚‹BBoxãƒªã‚µã‚¤ã‚ºï¼ˆã‚ºãƒ¬ç´¯ç©ãªã—ãƒ»è¦‹ãŸç›®ã¨ä¸€è‡´ï¼‰
function resizeByBBoxSnap(sh, corner, initBB, initPts, curPt){
  const g   = state.gridPx;
  const off = (state.gridOffset ?? (typeof GRID_PAD !== 'undefined' ? GRID_PAD : 0)); // â† è¦‹ãŸç›®ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ

  // åˆæœŸBBoxã®å·¦å³ä¸Šä¸‹ï¼ˆå›ºå®šåŸºæº–ï¼‰
  let L = initBB.x;
  let T = initBB.y;
  let R = initBB.x + initBB.w;
  let B = initBB.y + initBB.h;

  // ç¾åœ¨ãƒã‚¤ãƒ³ã‚¿ã‚’ã€Œoffsetä»˜ãã‚°ãƒªãƒƒãƒ‰ã€ã«ä¸¸ã‚ã‚‹
  const gx = Math.round((curPt.x - off) / g) * g + off;
  const gy = Math.round((curPt.y - off) / g) * g + off;

  // å‹•ãè¾ºã ã‘æ›´æ–°
  if (corner.includes('e')) R = gx;
  if (corner.includes('w')) L = gx;
  if (corner.includes('s')) B = gy;
  if (corner.includes('n')) T = gy;

  // æœ€å°ã‚µã‚¤ã‚ºï¼ˆè¦‹ãŸç›®5pxï¼‰
  const MIN = 5;
  if (R - L < MIN) R = L + MIN;
  if (B - T < MIN) B = T + MIN;

  // åˆæœŸBBoxåŸºæº–ã®â€œçµ¶å¯¾ã‚¹ã‚±ãƒ¼ãƒ«â€ï¼ˆå¢—åˆ†ãªã—ï¼‰
  const sx = (R - L) / initBB.w;
  const sy = (B - T) / initBB.h;
  const ox = initBB.x;
  const oy = initBB.y;

  sh.points = initPts.map(([x,y]) => [
    L + (x - ox) * sx,
    T + (y - oy) * sy
  ]);
}

  function snapMove(dx,dy,startPts){
  const cand=startPts.map(q=>[q[0]+dx,q[1]+dy]);
  // ä»£è¡¨ç‚¹ã ã‘ã§ãªãã€å…¨é ‚ç‚¹ã®ã†ã¡æœ€ã‚‚è¿‘ã„ã‚¹ãƒŠãƒƒãƒ—å€™è£œã«åˆã‚ã›ã‚‹
  let best=null, bestShift={dx:0,dy:0}, bestd=state.snapTol+1;
  for(const p of cand){
    const s = snapPointWithProjection(p[0], p[1]); // é ‚ç‚¹/ä¸­ç‚¹/è¾º/ã‚°ãƒªãƒƒãƒ‰
    if(s){
      const d = Math.hypot(s.x - p[0], s.y - p[1]);
      if (d < bestd){
        bestd = d;
        best = s;
        bestShift = { dx: dx + (s.x - p[0]), dy: dy + (s.y - p[1]) };
      }
    }
  }
  return best ? bestShift : {dx,dy};
}

  // ========= æ‰‹æ›¸ã & ã‚«ãƒ¼ã‚½ãƒ«ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ =========
  function setCanvasInteractivity(){
    const active = (state.tool==='draw' || state.tool==='erase');
    drawCanvas.style.pointerEvents = active ? 'auto' : 'none';
    if (state.tool==='draw'){
      drawCanvas.style.cursor = pencilCursor();
    } else {
      drawCanvas.style.cursor = 'crosshair';
    }
  }
  function pencilCursor(){
    const svg = encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none">
      <path d="M2 22l5.5-1.5L20 8 16 4 4.5 16.5 2 22z" fill="#444"/>
      <path d="M16 4l4 4" stroke="#222" stroke-width="2"/>
    </svg>`);
    return `url("data:image/svg+xml,${svg}") 0 16, crosshair`;
  }

  function redrawCanvas(){
    const W=drawCanvas.width/state.dpr, H=drawCanvas.height/state.dpr;
    ctx.clearRect(0,0,W,H);

    // 1) æç”»
    for(const s of state.drawings){
      ctx.beginPath(); ctx.lineWidth=2; ctx.lineJoin='round'; ctx.lineCap='round'; ctx.strokeStyle=s.color;
      const pts=s.pts; if(!pts.length) continue;
      ctx.moveTo(pts[0][0], pts[0][1]);
      for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0], pts[i][1]);
      ctx.stroke();
    }

    // 2) æ¶ˆå»ãƒã‚¹ã‚¯
    for(const e of state.eraseStrokes){
      ctx.save();
      ctx.globalCompositeOperation='destination-out';
      ctx.lineWidth=e.radius; ctx.lineCap='round'; ctx.lineJoin='round';
      const pts=e.pts; if(pts.length){
        ctx.beginPath(); ctx.moveTo(pts[0][0], pts[0][1]);
        for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0], pts[i][1]);
        ctx.stroke();
      }
      ctx.restore();
    }

    // 3) ãƒ‰ãƒ©ãƒƒã‚°ä¸­ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
    if(state.dragging && state.dragging.mode==='draw' && state.dragging.stroke){
      const s=state.dragging.stroke;
      ctx.beginPath(); ctx.lineWidth=2; ctx.lineJoin='round'; ctx.lineCap='round'; ctx.strokeStyle=s.color;
      const pts=s.pts; if(pts.length){ ctx.moveTo(pts[0][0], pts[0][1]); for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0], pts[i][1]); ctx.stroke(); }
    }
    if(state.dragging && state.dragging.mode==='erasePixel' && state.dragging.eraser){
      const e=state.dragging.eraser;
      ctx.save(); ctx.globalCompositeOperation='destination-out';
      ctx.lineWidth=e.radius; ctx.lineCap='round'; ctx.lineJoin='round';
      const pts=e.pts; if(pts.length){ ctx.beginPath(); ctx.moveTo(pts[0][0], pts[0][1]); for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0], pts[i][1]); ctx.stroke(); }
      ctx.restore();
    }
  }

  function addStrokePoint(p){ state.dragging.stroke.pts.push([p.x,p.y]); }
  function finishStroke(){ state.drawings.push(state.dragging.stroke); }

  // æ¶ˆã—ã‚´ãƒ 
  function handleEraserDown(e, p){
    const m=state.eraserMode;
    if(m==='clear'){ state.drawings=[]; state.eraseStrokes=[]; redrawCanvas(); pushHistory(); return; }
    if(m==='object'){ eraseNearestObject(p); redrawCanvas(); pushHistory(); return; }
    if(m==='pixel'){
      state.dragging={mode:'erasePixel', eraser:{pts:[[p.x,p.y]], radius:14}};
      try{ drawCanvas.setPointerCapture(e.pointerId); state.pointerCaptured=true; }catch(_){}
      redrawCanvas();
      return;
    }
  }
  function addErasePoint(p){
    if(state.dragging?.mode!=='erasePixel') return;
    state.dragging.eraser.pts.push([p.x,p.y]);
  }
  function finishEraseStroke(){
    if(state.dragging?.mode!=='erasePixel') return;
    state.eraseStrokes.push(state.dragging.eraser);
  }
  function eraseNearestObject(p){
    let bestd=1e9, idx=-1;
    state.drawings.forEach((s,i)=>{ const d=polylineDist(s.pts,p); if(d<bestd){ bestd=d; idx=i; } });
    if(idx>=0) state.drawings.splice(idx,1);
  }
  function polylineDist(pts, p){
    let bd=1e9; for(let i=1;i<pts.length;i++){ bd=Math.min(bd, pointSegDist(p,{x:pts[i-1][0],y:pts[i-1][1]},{x:pts[i][0],y:pts[i][1]})); }
    return bd;
  }
  function pointSegDist(p,a,b){
    const pr=projectPointToSeg(p,[a.x,a.y],[b.x,b.y]); return pr?pr.d:1e9;
  }

  // ========= å½¢çŠ¶åˆ¤å®šãƒ»ãƒ©ãƒ™ãƒ« =========
  function almostEq(a,b,eps=1e-2){ return Math.abs(a-b)<=eps; }
  function vsub(a,b){ return [a[0]-b[0], a[1]-b[1]]; }
  function vdot(a,b){ return a[0]*b[0] + a[1]*b[1]; }
  function vcross(a,b){ return a[0]*b[1] - a[1]*b[0]; }
  function vlen(a){ return Math.hypot(a[0],a[1]); }
  function isParallel(u,v,eps=1e-2){ return Math.abs(vcross(u,v))<=eps; }
  function isPerp(u,v,eps=1e-2){ return Math.abs(vdot(u,v))<=eps; }

  function autoType(points){
    const n=points.length;
    if(n===3) return 'tri';
    if(n===4){
      const p=points;
      const v0=vsub(p[1],p[0]);
      const v1=vsub(p[2],p[1]);
      const v2=vsub(p[3],p[2]);
      const v3=vsub(p[0],p[3]);
      const L=[vlen(v0), vlen(v1), vlen(v2), vlen(v3)];
      const allEqual = almostEq(L[0],L[1]) && almostEq(L[1],L[2]) && almostEq(L[2],L[3]);
      const para = isParallel(v0,v2) && isParallel(v1,v3);
      const rect = para && isPerp(v0,v1);
      const square = rect && allEqual;
      const rhombus = para && allEqual && !rect;
      const trapezoid = !para && (isParallel(v0,v2) || isParallel(v1,v3));
      if(square) return 'square';
      if(rect) return 'rect';
      if(rhombus) return 'rh';
      if(para) return 'para';
      if(trapezoid) return 'trap';
      return 'quad';
    }
    return `poly${n}`;
  }
  function labelByType(t){
    if(t==='tri') return 'ä¸‰è§’å½¢';
    if(t==='square') return 'æ­£æ–¹å½¢';
    if(t==='rect') return 'é•·æ–¹å½¢';
    if(t==='rh') return 'ã²ã—å½¢';
    if(t==='para') return 'å¹³è¡Œå››è¾ºå½¢';
    if(t==='trap') return 'å°å½¢';
    if(t==='quad') return 'å››è§’å½¢';
    if(t.startsWith('poly')){ const n=+t.slice(4); return `å¤šè§’å½¢ï¼ˆ${n}è§’å½¢ï¼‰`; }
    return 'å›³å½¢';
  }

  // ========= åˆ†å‰²å‡¦ç† =========
  function lineIntersectsPolygon(a,b, poly){
    let cnt=0; for(let i=0;i<poly.length;i++){ const P=poly[i], Q=poly[(i+1)%poly.length]; const I=segI([a.x,a.y],[b.x,b.y],P,Q); if(I) cnt++; if(cnt>=2) return true; }
    return false;
  }
  function vertexIndexOnPolygon(poly, p, tolPx){ for(let i=0;i<poly.length;i++){ if(dist(poly[i][0],poly[i][1],p.x,p.y)<=tolPx) return i; } return -1; }
  function cleanupCycle(arr){ if(arr.length>2 && dist(arr[0][0],arr[0][1],arr[arr.length-1][0],arr[arr.length-1][1])<0.5) arr.pop(); }
  function splitByVertexIndices(poly, ia, ib){
    const n=poly.length; if(n<3) return null; const path1=[], path2=[];
    for(let k=0;k<=(ib-ia+n)%n;k++) path1.push( poly[(ia+k)%n] );
    for(let k=0;k<=(ia-ib+n)%n;k++) path2.push( poly[(ib+k)%n] );
    if(dist(poly[ia][0],poly[ia][1],poly[ib][0],poly[ib][1])>0.5){ path1.push(poly[ia]); path2.push(poly[ib]); }
    cleanupCycle(path1); cleanupCycle(path2);
    if(path1.length>=3 && path2.length>=3) return [path1,path2];
    return null;
  }
  function splitPolygonByLine(pts, a, b){
    const left=[], right=[]; const n=pts.length; if(n<3) return null; const EPS=1e-6;
    function isLeft(a,b,p){ return (b.x-a.x)*(p[1]-a.y) - (b.y-a.y)*(p[0]-a.x); }
    function pushUniq(arr, p){ const m=arr.length; if(!m || dist(arr[m-1][0],arr[m-1][1],p[0],p[1])>0.5) arr.push([p[0],p[1]]); }
    function lineIntersectSeg(a,b,P,Q){ return segI([a.x,a.y],[b.x,b.y],P,Q); }
    for(let i=0;i<n;i++){
      const P=pts[i], Q=pts[(i+1)%n];
      const sP=isLeft(a,b,P), sQ=isLeft(a,b,Q);
      if(sP>=-EPS) pushUniq(left, P); if(sP<=EPS) pushUniq(right, P);
      if((sP>EPS && sQ<-EPS) || (sP<-EPS && sQ>EPS)){
        const I=lineIntersectSeg(a,b,P,Q); if(I){ const Ipt=[I.x,I.y]; pushUniq(left,Ipt); pushUniq(right,Ipt); }
      }else if(Math.abs(sQ)<=EPS && i<n-1){ pushUniq(left,Q); pushUniq(right,Q); }
    }
    cleanupCycle(left); cleanupCycle(right);
    if(left.length>=3 && right.length>=3) return [left,right];
    return null;
  }
  function finishSplit(){
    const {a,b}=state.dragging;
    if(!a || !b){ if(state.splitPreview) state.splitPreview.remove(); updateSplitPin(null); setTool('edit'); render(); return; }
    for(let t=state.shapes.length-1; t>=0; t--){
      const sh=state.shapes[t];
      if(!lineIntersectsPolygon(a,b, sh.points)) continue;

      const viA=vertexIndexOnPolygon(sh.points, a, 1.0);
      const viB=vertexIndexOnPolygon(sh.points, b, 1.0);
      let res=null;
      if(viA!==-1 && viB!==-1 && viA!==viB) res=splitByVertexIndices(sh.points, viA, viB);
      if(!res) res=splitPolygonByLine(sh.points, a, b);
      if(res && res.length===2){
        const base={...sh};
        state.shapes.splice(t,1);
        const s1Pts=res[0], s2Pts=res[1];
        const s1Type=autoType(s1Pts);
        const s2Type=autoType(s2Pts);
        state.shapes.splice(t,0,
          {...base,id:uid(),type:s1Type,points:s1Pts},
          {...base,id:uid(),type:s2Type,points:s2Pts}
        );
      }
    }
    if(state.splitPreview) state.splitPreview.remove();
    updateSplitPin(null);
    setTool('edit');
    render();
  }

  // ========= ãƒ©ãƒ™ãƒ«/å˜ä½ & UI =========
  function pxToCm(px){ return px/pxPerCm; }
  function fmtLen(px){ return pxToCm(px).toFixed(2); }
  function updateBadges(){
    const sh=state.sel;
    if(!sh){
      ui.selType.textContent='â€”';
      ui.w.textContent='â€”'; ui.h.textContent='â€”'; ui.vh.textContent='â€”';
      ui.wLabel.textContent='å¹…'; ui.hLabel.textContent='é«˜ã•';
      return;
    }
    const t = autoType(sh.points);
    ui.selType.textContent = labelByType(t);
    const bb=bbox(sh.points);
    ui.w.textContent=fmtLen(bb.w); ui.h.textContent=fmtLen(bb.h);
    document.getElementById('u1').textContent='cm'; document.getElementById('u2').textContent='cm';
    ui.vh.textContent=`${sh.points.length}`;

    if(t==='tri' || t==='para'){ ui.wLabel.textContent='åº•è¾º'; ui.hLabel.textContent='é«˜ã•'; }
    else if(t==='rect' || t==='square'){ ui.wLabel.textContent='æ¨ª'; ui.hLabel.textContent='ãŸã¦'; }
    else { ui.wLabel.textContent='å¹…'; ui.hLabel.textContent='é«˜ã•'; }
  }

  function updateNoteHeaderPanel(){
    const nid = state.selNoteId;
    if(!nid){ ui.notePanel.style.display='none'; return; }
    const note = state.notes.find(n=>n.id===nid);
    if(!note){ ui.notePanel.style.display='none'; return; }
    ui.notePanel.style.display='flex';
    ui.noteHdrColor.value = note.color || 'yellow';
    ui.noteHdrSize.value  = note.font  || 'm';
  }
  ui.noteHdrColor.addEventListener('change', ()=>{
    const nid=state.selNoteId; if(!nid) return;
    const n=state.notes.find(x=>x.id===nid); if(!n) return;
    n.color=ui.noteHdrColor.value; pushHistory(); render();
  });
  ui.noteHdrSize.addEventListener('change', ()=>{
    const nid=state.selNoteId; if(!nid) return;
    const n=state.notes.find(x=>x.id===nid); if(!n) return;
    n.font=ui.noteHdrSize.value; pushHistory(); render();
  });

  function updateModeBadge(){
    const m = state.tool;
    let txt = 'ç·¨é›†/ç§»å‹•';
    if(m==='draw'){ txt = `ãƒšãƒ³ï¼ˆ${penColorLabel(state.penColor)}ï¼‰`; }
    else if(m==='erase'){
      const label = (state.eraserMode==='pixel'?'ãƒ”ã‚¯ã‚»ãƒ«': state.eraserMode==='object'?'ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ':'å…¨æ¶ˆã—');
      txt = `æ¶ˆã—ã‚´ãƒ ï¼ˆ${label}ï¼‰`;
    }
    else if(m==='splitLine'){ txt = `åˆ†å‰²ï¼ˆå¸ç€${state.splitGridSnap?'ON':'OFF'}ï¼‰`; }
    else if(m==='text'){ txt = 'ãµã›ã‚“é…ç½®'; }
    ui.modeBadge.textContent = txt;
  }
  function penColorLabel(hex){
    if(hex==='#1f2937') return 'é»’';
    if(hex==='#ef4444') return 'èµ¤';
    if(hex==='#2563eb') return 'é’';
    if(hex==='#16a34a') return 'ç·‘';
    return hex;
  }

  function updateStatus(x,y, snapLabel){
    ui.statusBar.textContent = `(x: ${fmtLen(x)} cm, y: ${fmtLen(y)} cm) | Snap: ${snapLabel||'â€”'}`;
  }
  function classifySnap(x,y){
    const tol=state.snapTol;
    const segs=[]; const mids=[];
    for(const sh of state.shapes){
      const n=sh.points.length;
      for(let i=0;i<n;i++){
        const a=sh.points[i], b=sh.points[(i+1)%n];
        if(dist(x,y,a[0],a[1])<=tol) return 'Vertex';
        mids.push([(a[0]+b[0])/2,(a[1]+b[1])/2]);
        segs.push([a,b]);
      }
    }
    for(const m of mids){ if(dist(x,y,m[0],m[1])<=tol) return 'Midpoint'; }
    for(const s of segs){ const pr=projectPointToSeg({x,y}, s[0], s[1]); if(pr && pr.d<=tol) return 'Edge'; }
		const off = state.gridOffset || GRID_PAD;
		const gx = Math.round((x - off)/state.gridPx)*state.gridPx + off;
		const gy = Math.round((y - off)/state.gridPx)*state.gridPx + off;
    const dx=Math.abs(x-gx), dy=Math.abs(y-gy);
    if(Math.hypot(dx,dy)<=tol) return 'GridPt';
    if(dx<=tol || dy<=tol) return 'GridLine';
    const frame=nearestFrame(x,y); if(frame && frame.d<=tol) return 'Frame';
    return 'Free';
  }
  function updateStatusFromEvent(e){
    const p = (e.target===drawCanvas || e.target===board) ? pt(e) : null;
    if(!p){ return; }
    updateStatus(p.x, p.y, classifySnap(p.x,p.y));
  }

  // ========= å±¥æ­´ =========
  function snapshot(){ return JSON.stringify({shapes:state.shapes, notes:state.notes, drawings:state.drawings, eraseStrokes: state.eraseStrokes}); }
  function restore(json){
    const s=JSON.parse(json);
    state.shapes=s.shapes||[];
    state.notes=s.notes||[];
    state.drawings=s.drawings||[];
    state.eraseStrokes=s.eraseStrokes||[];
    drawGrid(); render();
  }
  function pushHistory(){ state.history.push(snapshot()); state.future=[]; }
  ui.undo.addEventListener('click', ()=>{ if(!state.history.length) return; const cur=snapshot(); const prev=state.history.pop(); state.future.push(cur); restore(prev); });
  ui.redo.addEventListener('click', ()=>{ if(!state.future.length) return; const cur=snapshot(); const next=state.future.pop(); state.history.push(cur); restore(next); });

  // ========= ä¿å­˜ãƒ»èª­ã¿è¾¼ã¿ãƒ»ãƒªã‚»ãƒƒãƒˆ =========
  ui.exportBtn.addEventListener('click', ()=>{
    const data=snapshot();
    const blob=new Blob([data],{type:'application/json'});
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='board.json'; a.click(); URL.revokeObjectURL(a.href);
  });
  document.getElementById('importLabel').addEventListener('click', ()=> ui.importInput.click());
  ui.importInput.addEventListener('change', async (e)=>{
    const f=e.target.files[0]; if(!f) return; const tx=await f.text(); restore(tx); pushHistory();
  });
  ui.resetBtn.addEventListener('click', ()=>{ location.reload(); });

  // ========= ãã®ä»–UI =========
  ui.toolbar.addEventListener('click', (e)=>{
    const b=e.target.closest('button'); if(!b) return;
    const add=b.getAttribute('data-add'); const tool=b.getAttribute('data-tool');
    [...ui.toolbar.querySelectorAll('button')].forEach(x=>x.classList.remove('active'));
    b.classList.add('active');
    if(add){ addShape(add); return; }
    if(tool){ setTool(tool); render(); return; }
  });
  ui.gridSize.addEventListener('change', ()=>{
    const cm=parseInt(ui.gridSize.value,10)||3; state.gridPx=pxPerCm*cm; drawGrid(); render(); redrawCursorOverlay();
  });
  ui.splitGridSnap.addEventListener('change', ()=> { state.splitGridSnap=ui.splitGridSnap.checked; updateModeBadge(); });
  ui.vertexEdit.addEventListener('change', ()=>{ state.vertexEdit=ui.vertexEdit.checked; render(); });

  ui.color.addEventListener('input', ()=>{ if(state.sel){ state.sel.fill=ui.color.value; state.sel.stroke=ui.color.value; pushHistory(); render(); } });
  ui.lockSize.addEventListener('change', ()=> state.lockSize=ui.lockSize.checked );
  ui.dup.addEventListener('click', ()=>{ if(!state.sel) return; const c=JSON.parse(JSON.stringify(state.sel)); c.id=uid(); c.points=c.points.map(p=>[p[0]+state.gridPx*0.5,p[1]+state.gridPx*0.5]); state.shapes.push(c); selectShape(c); pushHistory(); });
  ui.front.addEventListener('click', ()=>{ if(!state.sel) return; const i=state.shapes.findIndex(s=>s.id===state.sel.id); state.shapes.push(...state.shapes.splice(i,1)); pushHistory(); render(); });
  ui.back.addEventListener('click', ()=>{ if(!state.sel) return; const i=state.shapes.findIndex(s=>s.id===state.sel.id); state.shapes.unshift(...state.shapes.splice(i,1)); pushHistory(); render(); });
  ui.rotL.addEventListener('click', ()=> rotateSel(-15));
  ui.rotR.addEventListener('click', ()=> rotateSel(15));
  ui.flipH.addEventListener('click', ()=> flipSel(true,false));
  ui.flipV.addEventListener('click', ()=> flipSel(false,true));
  ui.deleteShape.addEventListener('click', ()=>{
    if(state.sel){ state.shapes=state.shapes.filter(s=>s.id!==state.sel.id); state.sel=null; pushHistory(); render(); }
  });
  ui.penColor.addEventListener('change', ()=> { state.penColor=ui.penColor.value; updateModeBadge(); setCanvasInteractivity(); render(); });
  ui.eraserMode.addEventListener('change', ()=> { state.eraserMode=ui.eraserMode.value; updateModeBadge(); redrawCursorOverlay(); });

  function rotateSel(deg){ if(!state.sel) return; const c=centroid(state.sel.points); const r=deg*Math.PI/180;
    state.sel.points=state.sel.points.map(([x,y])=>{const dx=x-c.x, dy=y-c.y; return [c.x+dx*Math.cos(r)-dy*Math.sin(r), c.y+dx*Math.sin(r)+dy*Math.cos(r)];});
    pushHistory(); render();
  }
  function flipSel(h,v){ if(!state.sel) return; const c=centroid(state.sel.points);
    state.sel.points=state.sel.points.map(([x,y])=>[ h?(2*c.x-x):x, v?(2*c.y-y):y ]);
    pushHistory(); render();
  }

  document.addEventListener('keydown', (e)=>{
    if(e.key==='Delete' && !document.activeElement.isContentEditable){
      if(state.sel){ state.shapes=state.shapes.filter(s=>s.id!==state.sel.id); state.sel=null; pushHistory(); render(); }
    }
  });

  // ========== ãƒ†ãƒ¼ãƒåˆ‡æ›¿ ==========
  function applyTheme(theme){
    document.documentElement.setAttribute('data-theme', theme);
    ui.themeToggle.textContent = (theme==='dark') ? 'â˜€ï¸' : 'ğŸŒ™';
    localStorage.setItem('board-theme', theme);
    drawGrid(); render(); redrawCursorOverlay();
  }
  ui.themeToggle.addEventListener('click', ()=>{
    const cur = document.documentElement.getAttribute('data-theme') || 'light';
    applyTheme(cur==='light' ? 'dark' : 'light');
  });
  (function initTheme(){
    const saved = localStorage.getItem('board-theme');
    if(saved){ applyTheme(saved); }
    else {
      const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      applyTheme(prefersDark ? 'dark' : 'light');
    }
  })();

  // ========== ã‚µã‚¤ãƒ‰ãƒãƒ¼æŠ˜ã‚ŠãŸãŸã¿ï¼ˆçªèµ·ã‚¿ãƒ–åˆ¶å¾¡ï¼‰ ==========
  function updateAsideTab(){
    const collapsed = document.body.classList.contains('aside-collapsed');
    ui.asideTab.textContent = collapsed ? 'â—€' : 'â–¶';
    ui.asideTab.title = collapsed ? 'ã‚µã‚¤ãƒ‰ãƒãƒ¼ã‚’ã²ã‚‰ã' : 'ã‚µã‚¤ãƒ‰ãƒãƒ¼ã‚’ãŸãŸã‚€';
    localStorage.setItem('aside-collapsed', collapsed ? '1' : '0');
  }
  ui.asideTab.addEventListener('click', ()=>{
    document.body.classList.toggle('aside-collapsed');
    updateAsideTab();
    setTimeout(()=>{ ensureLayout(); drawGrid(); render(); redrawCursorOverlay(); }, 10);
  });

  // ========= ã‚«ãƒ¼ã‚½ãƒ«ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼ˆæ¶ˆã—ã‚´ãƒ ã‚´ãƒ¼ã‚¹ãƒˆã®ã¿ï¼‰ =========
  function redrawCursorOverlay(){
    const W=cursorCanvas.width/state.dpr, H=cursorCanvas.height/state.dpr;
    cctx.clearRect(0,0,W,H);
    const p = state.pointerPos;

    if(state.tool==='erase'){
      cctx.save();
      cctx.beginPath();
      const r = 14/2; // ãƒ”ã‚¯ã‚»ãƒ«æ¶ˆã—ã®åŠå¾„ï¼ˆlineWidth=14ï¼‰
      cctx.arc(p.x, p.y, r, 0, Math.PI*2);
      cctx.fillStyle='rgba(180,180,180,0.2)';
      cctx.strokeStyle='rgba(120,120,120,0.6)';
      cctx.lineWidth=1;
      cctx.fill(); cctx.stroke();
      cctx.restore();
    }
  }

  // ========= èµ·å‹• =========
  function boot(){
  	// â˜… ç”»é¢ã‚ºãƒ¼ãƒ /å›è»¢/å¯è¦–ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆå¤‰åŒ–ã‚’ç›£è¦–
  	window.addEventListener('resize', onViewportChange, {passive:true});
  	window.addEventListener('orientationchange', onViewportChange, {passive:true});
  	try{
    	if (window.visualViewport) {
      	visualViewport.addEventListener('resize', onViewportChange, {passive:true});
      	visualViewport.addEventListener('scroll', onViewportChange, {passive:true});
    	}
  	}catch(_){}
  // â˜… iPadã®ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ã‚ºãƒ¼ãƒ &é•·æŠ¼ã—ãƒ¡ãƒ‹ãƒ¥ãƒ¼&é¸æŠé–‹å§‹ã‚’å°é–ï¼ˆä»˜ç®‹å†…ã¯è¨±å¯ï¼‰
	(function(){
		if (window.__iosTouchPatched) return; // â† äºŒé‡ç™»éŒ²é˜²æ­¢
		window.__iosTouchPatched = true;

		const inNote = (el)=> !!(el && (el.classList?.contains('note') || el.closest?.('.note')));

  // dblclick ã‚’å…ˆã«æ½°ã™
  document.addEventListener('dblclick', (e)=>{
    if(!inNote(e.target)) e.preventDefault();
  }, {capture:true, passive:false});

  // é€£ç¶šã‚¿ãƒƒãƒ—ï¼ˆãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ï¼‰ã«ã‚ˆã‚‹ã‚ºãƒ¼ãƒ ã‚‚æ½°ã™
  let lastTouchEnd = 0;
  document.addEventListener('touchend', (e)=>{
    if(inNote(e.target)) return;
    const now = Date.now();
    if (now - lastTouchEnd <= 350) {
      e.preventDefault();
    }
    lastTouchEnd = now;
  }, {capture:true, passive:false});

  // ãƒ”ãƒ³ãƒãªã©ã®ã‚¸ã‚§ã‚¹ãƒãƒ£é–‹å§‹ã‚‚æ½°ã™ï¼ˆä¿é™ºï¼‰
  document.addEventListener('gesturestart', (e)=>{
    if(!inNote(e.target)) e.preventDefault();
  }, {capture:true, passive:false});

  // é•·æŠ¼ã—ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼
  document.addEventListener('contextmenu', (e)=>{
    if(!inNote(e.target)) e.preventDefault();
  }, {capture:true, passive:false});

  // ãƒ†ã‚­ã‚¹ãƒˆé¸æŠé–‹å§‹
  document.addEventListener('selectstart', (e)=>{
    if(!inNote(e.target)) e.preventDefault();
  }, {capture:true, passive:false});
})();
  
  // ã‚¿ãƒƒãƒç«¯æœ«ã§ã¯ã‚¹ãƒŠãƒƒãƒ—ã‚’ã•ã‚‰ã«ç·©ã‚ã‚‹
  try{
    if (window.matchMedia && window.matchMedia('(pointer:coarse)').matches) {
      state.snapTol = Math.max(state.snapTol, 20);
    }
  }catch(_){}
    
    const savedAside = localStorage.getItem('aside-collapsed');
    if(savedAside===null){
      if(window.innerWidth < 820) document.body.classList.add('aside-collapsed'); // ç‹­ã„ç”»é¢ã¯ãƒ‡ãƒ•ã‚©ç•³ã‚€
    }else{
      if(savedAside==='1') document.body.classList.add('aside-collapsed');
      else document.body.classList.remove('aside-collapsed');
    }
    updateAsideTab();

    ensureLayout();
    const tick=()=>{
      const r=board.getBoundingClientRect();
      if(r.width<2 || r.height<2){ requestAnimationFrame(tick); return; }
      drawGrid(); render(); redrawCursorOverlay();

      // åˆæœŸå±¥æ­´ã‚’ç©ã‚€ï¼ˆUndoç©ºæ‰“ã¡å›é¿ï¼‰
      if(state.history.length===0){
        pushHistory();
      }

      const wrap=document.querySelector('.board-wrap');
      if(window.ResizeObserver && wrap){
        const ro=new ResizeObserver(()=>{ ensureLayout(); drawGrid(); render(); redrawCursorOverlay(); });
        ro.observe(wrap);
      }
      window.addEventListener('resize', ()=>{ ensureLayout(); drawGrid(); render(); redrawCursorOverlay(); });
    };
    requestAnimationFrame(tick);
  }
  window.addEventListener('load', boot);
</script>
</body>
</html>
